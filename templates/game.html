<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PWHL Game Details</title>
    <!-- Favicons: prefer small PNG; fallback to ICO -->
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png?v=2">
    <link rel="icon" href="/favicon.ico?v=2">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='PWHL_logo.png', v='2') }}">
    <meta name="theme-color" content="#160A3A">
    <style>
        :root {
            --pwhl-bg-1: #160A3A;
            --pwhl-bg-2: #251055;
            --pwhl-bg-3: #3B1E7A;
            --pwhl-surface: rgba(19, 13, 46, 0.75);
            --pwhl-surface-strong: rgba(25, 16, 60, 0.85);
            --pwhl-border: rgba(142, 124, 214, 0.25);
            --pwhl-accent: #8E7CD6;
            --pwhl-accent-strong: #B9A7FF;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif; background: linear-gradient(135deg, var(--pwhl-bg-1) 0%, var(--pwhl-bg-2) 48%, var(--pwhl-bg-3) 100%); color: #ffffff; line-height: 1.6; }
        .container { max-width: 1200px; margin: 0 auto; padding: 1rem; }
        .header { background: var(--pwhl-surface-strong); border: 1px solid var(--pwhl-border); border-radius: 0.5rem; padding: 1.5rem; margin-bottom: 2rem; display: flex; justify-content: space-between; align-items: center; }
        .back-btn { background-color: #4a5568; color: #ffffff; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer; text-decoration: none; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; transition: background-color 0.2s; }
        .back-btn:hover { background-color: #718096; }
        .btn { background-color: var(--pwhl-accent); color: #ffffff; border: none; padding: 0.5rem 1rem; border-radius: 0.375rem; cursor: pointer; text-decoration: none; display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; font-weight: 500; transition: background-color 0.2s; }
        .btn:hover { background-color: var(--pwhl-accent-strong); }
        .btn-sm { padding: 0.375rem 0.75rem; font-size: 0.75rem; }
        .game-info { flex: 1; text-align: center; margin: 0 2rem; }
        .game-title { font-size: 1.5rem; font-weight: 700; color: #4299e1; margin-bottom: 0.5rem; }
        .game-meta { color: #a0aec0; font-size: 0.875rem; }
    .tabs { background: var(--pwhl-surface-strong); border: 1px solid var(--pwhl-border); border-radius: 0.5rem; margin-bottom: 2rem; overflow: hidden; }
    .tab-list { display: flex; background: transparent; }
    .tab { background-color: transparent; color: #d6d3e9; border: none; padding: 1rem 2rem; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; flex: 1; text-align: center; font-size: 1.125rem; }
    .tab.active { background-color: transparent; color: var(--pwhl-accent-strong); border-bottom-color: var(--pwhl-accent-strong); }
        .tab-content { padding: 2rem; min-height: 400px; }
        .loading { text-align: center; padding: 4rem 2rem; color: #a0aec0; }
        .error { text-align: center; padding: 4rem 2rem; color: #f56565; }
        .game-summary { display: flex; flex-direction: column; gap: 2rem; }
    .section { background: var(--pwhl-surface); border: 1px solid var(--pwhl-border); border-radius: 0.5rem; padding: 1.5rem; }
        .section h3 { margin: 0 0 1.5rem 0; color: #4299e1; border-bottom: 1px solid #4a5568; padding-bottom: 0.75rem; font-size: 1.25rem; }
        .section h4 { margin: 1.5rem 0 1rem 0; color: #e2e8f0; font-size: 1rem; }
        .roster-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1rem; margin-top: 1rem; }
        .player-card { background-color: #2d3748; border: 1px solid #4a5568; border-radius: 0.375rem; padding: 1rem; min-width: 300px; transition: transform 0.2s, box-shadow 0.2s; }
        .player-card:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,0,0,0.3); }
        .play-by-play { display: flex; flex-direction: column; gap: 1rem; }
        .pbp-table { width: 100%; border-collapse: collapse; font-size: 12px; }
        .pbp-table th, .pbp-table td { padding: 6px 8px; border-bottom: 1px solid #4a5568; white-space: nowrap; }
        .pbp-table thead th { position: sticky; top: 0; background-color: #1a202c; z-index: 1; text-transform: none; font-weight: 600; color: #e2e8f0; }
        .pbp-col-center { text-align: center; }
        .pbp-col-left { text-align: left; }
        .pbp-col-right { text-align: right; }
        .events-list { max-height: 600px; overflow-y: auto; border: 1px solid #4a5568; border-radius: 0.5rem; }
        .event-item { display: flex; align-items: center; gap: 1rem; padding: 1rem; border-bottom: 1px solid #4a5568; background-color: #1e2329; }
        .event-item:last-child { border-bottom: none; }
        .event-item.goal { background-color: rgba(72,187,120,0.1); border-left: 4px solid #48bb78; }
        .event-item.penalty { background-color: rgba(245,101,101,0.1); border-left: 4px solid #f56565; }
        .event-time { min-width: 100px; text-align: center; font-family: 'Courier New', monospace; color: #a0aec0; font-size: 0.875rem; }
        .event-description { flex: 1; color: #e2e8f0; }
        .csv-btn { background-color: #3B1E7A; color: #fff; border: none; border-radius: 10px; padding: 0.7rem 1.5rem; font-size: 1rem; font-weight: 500; margin-right: 0.5rem; margin-bottom: 0.5rem; cursor: pointer; box-shadow: none; transition: background 0.2s; }
    .csv-btn:hover { background-color: #4a2899; }
    .tab-list .csv-btn { margin-top: 6px; }
    .pbp-scroll { max-height: 70vh; overflow-y: auto; }
        @media (max-width: 768px) {
            .header { flex-direction: column; text-align: center; gap: 1rem; }
            .game-info { margin: 0; }
            .tab-list { flex-direction: column; }
            .roster-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <a href="/" class="back-btn">
                ‚Üê Back to Schedule
            </a>
            <div class="game-info">
                <div class="game-title" id="gameTitle">Loading Game...</div>
                <div class="game-meta" id="gameMeta">Game Details</div>
            </div>
            <div style="width: 120px;"></div> <!-- Spacer for centering -->
        </div>

        <div class="tabs">
            <div class="tab-list" style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <button class="tab active" onclick="switchTab('lineups')">üìã Lineups</button>
                    <button class="tab" onclick="switchTab('playbyplay')">‚ö° Play-by-Play</button>
                    <button class="tab" onclick="switchTab('gamereport')">üìä Game Report</button>
                </div>
                <div>
                    <button id="export-lineups-btn" class="csv-btn" onclick="exportLineups()">Export CSV</button>
                    <button id="export-playbyplay-btn" class="csv-btn" onclick="exportPlayByPlay()" style="display: none;">Export CSV</button>
                </div>
            </div>
            <div class="tab-content">
                <div id="lineups-content" class="tab-panel active">
                    <div class="loading">Loading lineup data...</div>
                </div>
                <div id="playbyplay-content" class="tab-panel" style="display: none;">
                    <div class="loading">Loading play-by-play data...</div>
                </div>
                <div id="gamereport-content" class="tab-panel" style="display:none;">
                    <div class="slicers-wrapper" style="background:rgba(19,13,46,.75);border-bottom:1px solid rgba(142,124,214,.25);padding:.75rem 2rem;display:flex;flex-direction:column;gap:.6rem;">
                        <div class="slicers" style="display:flex;flex-wrap:wrap;gap:1rem;align-items:flex-start;">
                            <div class="filter-group" style="display:flex;flex-direction:column;min-width:170px;">
                                <label class="filter-label" style="margin-bottom:.4rem;font-weight:600;color:#e2e8f0;font-size:.7rem;letter-spacing:.05em;text-transform:uppercase;">Strength</label>
                                <select class="filter-select" id="grStrength" onchange="loadGameReport()" style="width:170px;background:#4a5568;border:1px solid #718096;border-radius:.375rem;padding:.45rem .6rem;color:#fff;font-size:.7rem;">
                                    <option value="All">All</option>
                                    <option value="EV">EV</option>
                                    <option value="5v5">5v5</option>
                                    <option value="PP">PP</option>
                                    <option value="SH">SH</option>
                                </select>
                            </div>
                            <div class="filter-group" style="display:flex;flex-direction:column;min-width:170px;">
                                <label class="filter-label" style="margin-bottom:.4rem;font-weight:600;color:#e2e8f0;font-size:.7rem;letter-spacing:.05em;text-transform:uppercase;">Perspective</label>
                                <select class="filter-select" id="grPerspective" onchange="loadGameReport()" style="width:170px;background:#4a5568;border:1px solid #718096;border-radius:.375rem;padding:.45rem .6rem;color:#fff;font-size:.7rem;">
                                    <!-- Options populated dynamically with team names -->
                                </select>
                            </div>
                            <div class="filter-group" style="display:flex;flex-direction:column;min-width:170px;">
                                <label class="filter-label" style="margin-bottom:.4rem;font-weight:600;color:#e2e8f0;font-size:.7rem;letter-spacing:.05em;text-transform:uppercase;">Event</label>
                                <select class="filter-select" id="grEvents" onchange="loadGameReport()" style="width:170px;background:#4a5568;border:1px solid #718096;border-radius:.375rem;padding:.45rem .6rem;color:#fff;font-size:.7rem;">
                                    <option value="All">All</option>
                                    <option value="Shot">Shot</option>
                                    <option value="Goal">Goal</option>
                                    <option value="Miss">Miss</option>
                                    <option value="Block">Block</option>
                                </select>
                            </div>
                            <div class="filter-group" style="display:flex;flex-direction:column;min-width:170px;">
                                <label class="filter-label" style="margin-bottom:.4rem;font-weight:600;color:#e2e8f0;font-size:.7rem;letter-spacing:.05em;text-transform:uppercase;">Table</label>
                                <select class="filter-select" id="grTable" onchange="loadGameReport()" style="width:170px;background:#4a5568;border:1px solid #718096;border-radius:.375rem;padding:.45rem .6rem;color:#fff;font-size:.7rem;">
                                    <option value="skaters">Skaters</option>
                                    <option value="goalies">Goalies</option>
                                    <option value="teams">Teams</option>
                                </select>
                            </div>
                            <div class="filter-group" style="display:flex;flex-direction:column;justify-content:flex-end;">
                                <button onclick="resetGameReportFilters()" style="background:#2d3748;color:#e2e8f0;border:1px solid #4a5568;padding:.45rem .8rem;border-radius:.375rem;font-size:.7rem;cursor:pointer;">Reset Filters</button>
                            </div>
                        </div>
                    </div>
                    <div style="padding:.5rem .5rem;">
                        <div id="gamereport-shotmap-wrapper" style="display:flex;gap:1rem;align-items:flex-start;margin-bottom:2rem;margin-top:.75rem;">
                            <div class="rink defensive-zone" style="flex:1;display:flex;flex-direction:column;max-width:450px;">
                                <h3 style="margin:0 0 1rem;font-size:1.1rem;font-weight:600;color:#b9a7ff;text-align:center;">Defensive Zone</h3>
                                <div class="zone-wrap" style="position:relative;width:100%;aspect-ratio:75/85;background:rgba(19,13,46,.75);border:1px solid rgba(142,124,214,.25);border-radius:.65rem;">
                                    <canvas id="defRinkBase" class="rink-base" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas>
                                    <canvas id="defShotCanvas" class="zone-canvas" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas>
                                </div>
                            </div>
                            <div id="gamereport-kpis" style="flex:0 0 240px;display:flex;flex-direction:column;gap:.75rem;"></div>
                            <div class="rink offensive-zone" style="flex:1;display:flex;flex-direction:column;max-width:450px;">
                                <h3 style="margin:0 0 1rem;font-size:1.1rem;font-weight:600;color:#b9a7ff;text-align:center;">Offensive Zone</h3>
                                <div class="zone-wrap" style="position:relative;width:100%;aspect-ratio:75/85;background:rgba(19,13,46,.75);border:1px solid rgba(142,124,214,.25);border-radius:.65rem;">
                                    <canvas id="offRinkBase" class="rink-base" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas>
                                    <canvas id="offShotCanvas" class="zone-canvas" style="position:absolute;top:0;left:0;width:100%;height:100%;"></canvas>
                                </div>
                            </div>
                        </div>
                        <div id="gamereport-table" style="overflow-x:auto;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentGameId = null;
        let activeTab = 'lineups';

        // Get game ID from URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        currentGameId = urlParams.get('id');

        if (!currentGameId) {
            document.getElementById('gameTitle').innerText = 'No Game Selected';
            document.getElementById('gameMeta').innerText = 'Please go back and select a game';
        } else {
            loadGameData();
        }

        async function loadGameData() {
            try {
                // Load basic game info first (we'll get this from schedule API)
                await loadGameInfo();
                // Preload both summary and play-by-play so we can resolve shootout teams and avoid tab refetches
                const [sumResp, pbpResp] = await Promise.all([
                    fetch(`/api/game/summary/${currentGameId}`).catch(() => null),
                    fetch(`/api/game/playbyplay/${currentGameId}`).catch(() => null)
                ]);
                if (sumResp) {
                    try { const sumData = await sumResp.json(); if (sumResp.ok) window.currentGameSummaryData = sumData; } catch {}
                }
                if (pbpResp) {
                    try { const pbpData = await pbpResp.json(); if (pbpResp.ok) window.currentPlayByPlayData = pbpData; } catch {}
                }
                // Render the active tab from cached data
                await loadTabContent(activeTab);
            } catch (error) {
                console.error('Error loading game data:', error);
            }
        }

        async function loadGameInfo() {
            try {
                const response = await fetch(`/api/game/info/${currentGameId}`);
                const gameInfo = await response.json();
                
                if (response.ok) {
                    // Update title with proper format: "{Date} - {AwayTeam} at {HomeTeam}"
                    const title = `${gameInfo.date} - ${gameInfo.away_team} at ${gameInfo.home_team}`;
                    document.getElementById('gameTitle').innerText = title;
                    
                    // Update meta info
                    let meta = `${gameInfo.season_year} ${gameInfo.season_state}`;
                    if (gameInfo.status.includes('Final')) {
                        meta += ` | Final: ${gameInfo.away_team} ${gameInfo.away_score} - ${gameInfo.home_score} ${gameInfo.home_team}`;
                    } else {
                        meta += ` | ${gameInfo.status}`;
                    }
                    document.getElementById('gameMeta').innerText = meta;
                    
                    // Store game info for use in other functions
                    window.currentGameInfo = gameInfo;
                } else {
                    document.getElementById('gameTitle').innerText = `Game ${currentGameId}`;
                    document.getElementById('gameMeta').innerText = `Game details unavailable`;
                }
            } catch (error) {
                console.error('Error loading game info:', error);
                document.getElementById('gameTitle').innerText = `Game ${currentGameId}`;
                document.getElementById('gameMeta').innerText = `PWHL Game Details`;
            }
        }

        async function loadTabContent(tabName) {
            const contentId = `${tabName}-content`;
            const contentDiv = document.getElementById(contentId);
            
            if (!contentDiv) return;

            // Show loading state (but skip for gamereport to preserve static controls)
            if (tabName !== 'gamereport') {
                contentDiv.innerHTML = '<div class="loading">Loading...</div>';
            }

            try {
                let data = null; let formatFunction = null;
                if (tabName === 'lineups') {
                    formatFunction = formatGameSummary;
                    data = window.currentGameSummaryData;
                    if (!data) {
                        const r = await fetch(`/api/game/summary/${currentGameId}`);
                        const j = await r.json();
                        if (r.ok) { window.currentGameSummaryData = j; data = j; }
                    }
                } else if (tabName === 'playbyplay') {
                    // Ensure summary exists for lineup-based lookups
                    if (!window.currentGameSummaryData) {
                        const rs = await fetch(`/api/game/summary/${currentGameId}`);
                        const js = await rs.json();
                        if (rs.ok) window.currentGameSummaryData = js;
                    }
                    formatFunction = formatPlayByPlay;
                    data = window.currentPlayByPlayData;
                    if (!data) {
                        const r = await fetch(`/api/game/playbyplay/${currentGameId}`);
                        const j = await r.json();
                        if (r.ok) { window.currentPlayByPlayData = j; data = j; }
                    }
                } else if (tabName === 'gamereport') {
                    // Remove only the loading spinner to preserve Game Report controls
                    const loadingEl = contentDiv.querySelector('.loading');
                    if (loadingEl) loadingEl.remove();
                    await ensureGameInfo();
                    // Small delay to ensure DOM is painted after display:block
                    await new Promise(resolve => setTimeout(resolve, 10));
                    await loadGameReport();
                    return; // skip generic formatter
                }
                if (data) {
                    contentDiv.innerHTML = formatFunction(data);
                } else {
                    contentDiv.innerHTML = `<div class="error">Error loading ${tabName}: data unavailable</div>`;
                }
            } catch (error) {
                console.error(`Error loading ${tabName}:`, error);
                contentDiv.innerHTML = `<div class="error">Error loading ${tabName}. Please try again.</div>`;
            }
        }

        function switchTab(tabName) {
            // Update active tab
            activeTab = tabName;
            
            // Update tab buttons
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content visibility FIRST
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.style.display = 'none';
            });
            document.getElementById(`${tabName}-content`).style.display = 'block';

            // Show/hide appropriate export buttons
            if (tabName === 'lineups') {
                document.getElementById('export-lineups-btn').style.display = 'inline-block';
                document.getElementById('export-playbyplay-btn').style.display = 'none';
            } else if (tabName === 'playbyplay') {
                document.getElementById('export-lineups-btn').style.display = 'none';
                document.getElementById('export-playbyplay-btn').style.display = 'inline-block';
            } else if (tabName === 'gamereport') {
                document.getElementById('export-lineups-btn').style.display = 'none';
                document.getElementById('export-playbyplay-btn').style.display = 'none';
            }

            // Load content for the new tab (DOM is now visible)
            loadTabContent(tabName);
        }

        async function ensureGameInfo(){
            if(!window.currentGameInfo){
                try{ const r=await fetch(`/api/game/info/${currentGameId}`); const j=await r.json(); if(r.ok) window.currentGameInfo=j; }catch(e){}
            }
        }

        function resetGameReportFilters(){
            const s=document.getElementById('grStrength'); if(s) s.value='All';
            const p=document.getElementById('grPerspective'); if(p && p.options.length>0) p.selectedIndex=0;
            const t=document.getElementById('grTable'); if(t) t.value='skaters';
            const evs=document.getElementById('grEvents'); if(evs) evs.value='All';
            loadGameReport();
        }

        function populateGameReportPerspective(){
            const perspSel=document.getElementById('grPerspective');
            if(!perspSel || perspSel.options.length>0) return; // already populated
            const gameInfo=window.currentGameInfo || {};
            const home=gameInfo.home_team || 'Home Team';
            const away=gameInfo.away_team || 'Away Team';
            perspSel.innerHTML=`<option value="${home}">${home}</option><option value="${away}">${away}</option>`;
        }

        async function loadGameReport(){
            // Guard DOM lookups to avoid null errors if tab not yet in DOM
            const strengthSel=document.getElementById('grStrength');
            const perspSel=document.getElementById('grPerspective');
            const tableSel=document.getElementById('grTable');
            const eventsSelBox=document.getElementById('grEvents');
            if(!strengthSel || !perspSel || !tableSel || !eventsSelBox){
                console.warn('Game Report controls not found yet; skipping render');
                return;
            }
            
            await ensureGameInfo();
            populateGameReportPerspective();
            
            const strength=strengthSel.value || 'All';
            const perspective=perspSel.value || 'For';
            const table=tableSel.value || 'skaters';
            const eventFilter=eventsSelBox.value || 'All'; // Single value now

            try{
                // Ensure PBP is available
                if(!window.currentPlayByPlayData){
                    const r=await fetch(`/api/game/playbyplay/${currentGameId}`);
                    const j=await r.json();
                    if(r.ok) window.currentPlayByPlayData=j; else throw new Error('PBP unavailable');
                }
                // Build final events and strengths from in-memory data
                const gameInfo=window.currentGameInfo || {};
                const { finalEvents, strengths } = buildFinalEventsFromPBP(window.currentPlayByPlayData||[], window.currentGameSummaryData, gameInfo);

                // Filter helper by selected strength
                const passStrength=(s)=>{
                    if(!s) return strength==='All';
                    const m=s.match(/^(\d+)v(\d+)$/i);
                    if(!m) return strength==='All';
                    const a=parseInt(m[1],10), b=parseInt(m[2],10);
                    if(strength==='All') return true;
                    if(strength==='EV') return a===b;
                    if(strength==='5v5') return a===5 && b===5;
                    if(strength==='PP') return a>b;
                    if(strength==='SH') return a<b;
                    return true;
                };

                // Perspective handling: relative to HOME team
                const ids=getGameTeamIds(gameInfo);
                const homeId=ids.homeId, awayId=ids.awayId;
                const forTeamId = (perspective==='For')? homeId: awayId;
                const againstTeamId = (perspective==='For')? awayId: homeId;

                // Build attempts for shotmap and KPIs (with event filter for shotmap only)
                const allAttempts=[]; // All shot attempts for KPI calculations (ignores Event filter)
                const filteredAttempts=[]; // Filtered by Event for shotmap display
                
                finalEvents.forEach((ev,idx)=>{
                    const lbl = prettifyEventLabel(getEventLabel(ev));
                    const lblKey = String(lbl).toLowerCase();
                    // Only include shot attempts: shot, goal, miss, block
                    if(!['shot','goal','miss','block'].includes(lblKey)) return;
                    
                    const s = strengths[idx]||'';
                    if(!passStrength(s)) return;
                    
                    const tid = String(ev._computedTeamId||'');
                    const d=ev.details||{};
                    let period = d.period ? (d.period.shortName || d.period.id || '') : '';
                    if (getEventLabel(ev)==='SO_goal' || getEventLabel(ev)==='SO_miss') period = 'SO';
                    
                    const x = (ev._x !== undefined) ? ev._x : (d.xLocation !== undefined ? d.xLocation : d.xCoord);
                    const y = (ev._y !== undefined) ? ev._y : (d.yLocation !== undefined ? d.yLocation : d.yCoord);
                    
                    // Determine team names
                    const eventTeamName = getTeamNameById(tid) || (tid===homeId?gameInfo.home_team: tid===awayId?gameInfo.away_team: '');
                    const opposingTeamName = (tid===homeId) ? gameInfo.away_team : gameInfo.home_team;
                    
                    const attempt = {
                        period,
                        event: lbl,
                        eventKey: lblKey,
                        team_for: eventTeamName,
                        team_against: opposingTeamName,
                        teamId: tid,
                        strength: s,
                        x: x,
                        y: y,
                        adj_x: (x||x===0)?(((x-300)/300*100).toFixed(1)): null,
                        adj_y: (y||y===0)?(((y-150)/150*42.5).toFixed(1)): null
                    };
                    
                    allAttempts.push(attempt);
                    
                    // Apply event filter for shotmap display
                    if(eventFilter==='All' || lblKey===eventFilter.toLowerCase()){
                        filteredAttempts.push(attempt);
                    }
                });

                // KPIs by team (Home/Away), using ALL attempts (ignoring Event filter)
                const aggTeam = (tid)=>{
                    const rows = allAttempts.filter(a=>a.teamId===tid);
                    const countBy = (evName)=> rows.filter(r=>r.eventKey===evName.toLowerCase()).length;
                    const goals = countBy('goal');
                    const shotsOn = countBy('shot');
                    const misses = countBy('miss');
                    const blocks = countBy('block');
                    const attemptsTot = goals + shotsOn + misses + blocks;
                    return { attempts: attemptsTot, shots: shotsOn, goals, misses, blocks };
                };
                const homeAgg = aggTeam(homeId);
                const awayAgg = aggTeam(awayId);

                // Calculate KPIs with proper formulas
                const CA = homeAgg.attempts; // Corsi Against (home perspective)
                const CF = awayAgg.attempts; // Corsi For
                const CFpct = (CF+CA)>0 ? ((CF/(CF+CA))*100).toFixed(1) : '‚Äî';
                
                const SA = homeAgg.shots;
                const SF = awayAgg.shots;
                const SFpct = (SF+SA)>0 ? ((SF/(SF+SA))*100).toFixed(1) : '‚Äî';
                
                const GA = homeAgg.goals;
                const GF = awayAgg.goals;
                const GFpct = (GF+GA)>0 ? ((GF/(GF+GA))*100).toFixed(1) : '‚Äî';
                
                // Goaltending/Shooting metrics
                const SvPct = SA>0 ? (((SA-GA)/SA)*100).toFixed(1) : '‚Äî';
                const ShPct = SF>0 ? ((GF/SF)*100).toFixed(1) : '‚Äî';
                const PDO = (SvPct!=='‚Äî' && ShPct!=='‚Äî') ? (parseFloat(SvPct)+parseFloat(ShPct)).toFixed(1) : '‚Äî';

                // Render KPIs (pass attempts array for recalculation)
                renderGameReportKPIs({ attempts: allAttempts });

                // Shotmap: use filtered attempts
                renderGameReportShotmap({ attempts: filteredAttempts });

                // Table rows - use ALL attempts (ignore Event filter), only filter by strength
                let tableRows=[];
                if(table==='teams'){
                    tableRows = [
                        { Team: gameInfo.home_team||'Home', Attempts: homeAgg.attempts, Shots: homeAgg.shots, Goals: homeAgg.goals, Misses: homeAgg.misses, Blocks: homeAgg.blocks },
                        { Team: gameInfo.away_team||'Away', Attempts: awayAgg.attempts, Shots: awayAgg.shots, Goals: awayAgg.goals, Misses: awayAgg.misses, Blocks: awayAgg.blocks }
                    ];
                } else if(table==='skaters'){
                    // Aggregate by shooter/scorer using ALL attempts
                    const lineupIdx = buildLineupIndex(window.currentGameSummaryData, gameInfo);
                    const skMap = new Map();
                    finalEvents.forEach((ev,idx)=>{
                        const lbl = prettifyEventLabel(getEventLabel(ev));
                        const lblKey = String(lbl).toLowerCase();
                        if(!['shot','goal','miss','block'].includes(lblKey)) return;
                        const s = strengths[idx]||''; if(!passStrength(s)) return;
                        const d=ev.details||{}; const tid=String(ev._computedTeamId||'');
                        let player = null; if(lblKey==='goal'){ player = ev._mergedScorer || d.scoredBy || d.scorer || d.player; } else { player = d.shooter || d.player; }
                        if(!player) return;
                        const name = player.name || player.fullName || `${player.firstName||''} ${player.lastName||''}`.trim() || 'Unknown';
                        const key = `${name}|${tid}`;
                        if(!skMap.has(key)) skMap.set(key, { Team:getTeamNameById(tid) || (tid===homeId?gameInfo.home_team: tid===awayId?gameInfo.away_team:''), Player:name, Goals:0, Shots:0, Misses:0, Blocks:0, Attempts:0 });
                        const rec = skMap.get(key);
                        if(lblKey==='goal'){ rec.Goals++; rec.Attempts++; }
                        else if(lblKey==='shot'){ rec.Shots++; rec.Attempts++; }
                        else if(lblKey==='miss'){ rec.Misses++; rec.Attempts++; }
                        else if(lblKey==='block'){ rec.Blocks++; rec.Attempts++; }
                    });
                    tableRows = Array.from(skMap.values());
                } else if(table==='goalies'){
                    // Aggregate by goalie using ALL shots/goals
                    const gMap = new Map();
                    finalEvents.forEach((ev,idx)=>{
                        const lbl = prettifyEventLabel(getEventLabel(ev));
                        const k=String(lbl).toLowerCase();
                        if(!(k==='shot' || k==='goal')) return;
                        const s=strengths[idx]||''; if(!passStrength(s)) return;
                        const d=ev.details||{}; const goalie=d.goalie; if(!goalie) return;
                        const shooterTid=String(ev._computedTeamId||'');
                        let goalieTid = getPlayerTeamIdFromLineups(goalie, buildLineupIndex(window.currentGameSummaryData, gameInfo), gameInfo);
                        if(!goalieTid){ goalieTid = (shooterTid===homeId?awayId:homeId); }
                        const name = goalie.name || goalie.fullName || `${goalie.firstName||''} ${goalie.lastName||''}`.trim() || 'Unknown';
                        const key = `${name}|${goalieTid}`;
                        if(!gMap.has(key)) gMap.set(key, { Team:getTeamNameById(goalieTid) || (goalieTid===homeId?gameInfo.home_team:gameInfo.away_team), Goalie:name, SA:0, GA:0, SV:0, 'SV%':'' });
                        const rec=gMap.get(key);
                        rec.SA++;
                        if(k==='goal') rec.GA++;
                    });
                    gMap.forEach(rec=>{ rec.SV = Math.max(0, rec.SA - rec.GA); rec['SV%'] = rec.SA>0 ? ( (rec.SV/rec.SA)*100 ).toFixed(1)+'%' : '‚Äî'; });
                    tableRows = Array.from(gMap.values());
                }
                renderGameReportTable(tableRows);
            }catch(e){
                console.error('Failed to compute Game Report in-browser:', e);
                renderGameReportKPIs(null);
                renderGameReportShotmap(null);
                renderGameReportTable([]);
            }
        }

        function renderGameReportKPIs(data){
            const cont = document.getElementById('gamereport-kpis');
            if(!cont) return;
            if(!data || !data.attempts || data.attempts.length === 0){
                cont.innerHTML = '<div style="opacity:0.6;font-size:.85rem;padding:1rem;text-align:center;color:#b7b3cf;">No data for selected filters.</div>';
                return;
            }
            
            // Get selected team from Perspective slicer
            const perspectiveSelect = document.getElementById('grPerspective');
            const forTeam = perspectiveSelect ? perspectiveSelect.value : '';
            
            const attempts = data.attempts;
            
            // Calculate KPIs based on selected perspective team
            let CA = 0, CF = 0, SA = 0, SF = 0, GA = 0, GF = 0;
            
            attempts.forEach(a => {
                const evt = a.event || '';
                // CF = attempts FOR the selected team, CA = attempts AGAINST the selected team
                const isFor = a.team_for === forTeam;
                
                // Corsi: Shot, Goal, Miss, Block
                if(['Shot', 'Goal', 'Miss', 'Block'].includes(evt)){
                    if(isFor) CF++; else CA++;
                }
                
                // Shots: Shot, Goal
                if(['Shot', 'Goal'].includes(evt)){
                    if(isFor) SF++; else SA++;
                }
                
                // Goals
                if(evt === 'Goal'){
                    if(isFor) GF++; else GA++;
                }
            });
            
            // Calculate percentages
            const CF_pct = (CF + CA) > 0 ? ((CF / (CF + CA)) * 100).toFixed(1) : '0.0';
            const SF_pct = (SF + SA) > 0 ? ((SF / (SF + SA)) * 100).toFixed(1) : '0.0';
            const GF_pct = (GF + GA) > 0 ? ((GF / (GF + GA)) * 100).toFixed(1) : '0.0';
            const Sv_pct = SA > 0 ? (((SA - GA) / SA) * 100).toFixed(1) : '0.0';
            const Sh_pct = SF > 0 ? ((GF / SF) * 100).toFixed(1) : '0.0';
            const PDO = (parseFloat(Sv_pct) + parseFloat(Sh_pct)).toFixed(1);
            
            cont.innerHTML = `
                <div style="display:flex;flex-direction:column;gap:1rem;">
                    <div style="background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:.55rem;padding:.75rem;">
                        <div style="font-size:.65rem;letter-spacing:.05em;font-weight:600;color:#b7b3cf;text-transform:uppercase;margin-bottom:.5rem;text-align:center;">Corsi</div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem;text-align:center;">
                            <div><div style="font-size:.55rem;color:#999;">CA</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${CA}</div></div>
                            <div style="border-left:1px solid rgba(255,255,255,.1);border-right:1px solid rgba(255,255,255,.1);"><div style="font-size:.55rem;color:#999;">CF%</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${CF_pct}%</div></div>
                            <div><div style="font-size:.55rem;color:#999;">CF</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${CF}</div></div>
                        </div>
                    </div>
                    
                    <div style="background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:.55rem;padding:.75rem;">
                        <div style="font-size:.65rem;letter-spacing:.05em;font-weight:600;color:#b7b3cf;text-transform:uppercase;margin-bottom:.5rem;text-align:center;">Shots</div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem;text-align:center;">
                            <div><div style="font-size:.55rem;color:#999;">SA</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${SA}</div></div>
                            <div style="border-left:1px solid rgba(255,255,255,.1);border-right:1px solid rgba(255,255,255,.1);"><div style="font-size:.55rem;color:#999;">SF%</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${SF_pct}%</div></div>
                            <div><div style="font-size:.55rem;color:#999;">SF</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${SF}</div></div>
                        </div>
                    </div>
                    
                    <div style="background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:.55rem;padding:.75rem;">
                        <div style="font-size:.65rem;letter-spacing:.05em;font-weight:600;color:#b7b3cf;text-transform:uppercase;margin-bottom:.5rem;text-align:center;">Goals</div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem;text-align:center;">
                            <div><div style="font-size:.55rem;color:#999;">GA</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${GA}</div></div>
                            <div style="border-left:1px solid rgba(255,255,255,.1);border-right:1px solid rgba(255,255,255,.1);"><div style="font-size:.55rem;color:#999;">GF%</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${GF_pct}%</div></div>
                            <div><div style="font-size:.55rem;color:#999;">GF</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${GF}</div></div>
                        </div>
                    </div>
                    
                    <div style="background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:.55rem;padding:.75rem;">
                        <div style="font-size:.65rem;letter-spacing:.05em;font-weight:600;color:#b7b3cf;text-transform:uppercase;margin-bottom:.5rem;text-align:center;">Expected Goals</div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem;text-align:center;">
                            <div><div style="font-size:.55rem;color:#999;">xGA</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">‚Äî</div></div>
                            <div style="border-left:1px solid rgba(255,255,255,.1);border-right:1px solid rgba(255,255,255,.1);"><div style="font-size:.55rem;color:#999;">xGF%</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">‚Äî</div></div>
                            <div><div style="font-size:.55rem;color:#999;">xGF</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">‚Äî</div></div>
                        </div>
                    </div>
                    
                    <div style="background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.08);border-radius:.55rem;padding:.75rem;">
                        <div style="font-size:.65rem;letter-spacing:.05em;font-weight:600;color:#b7b3cf;text-transform:uppercase;margin-bottom:.5rem;text-align:center;">Goaltending / Shooting</div>
                        <div style="display:grid;grid-template-columns:1fr 1fr 1fr;gap:.5rem;text-align:center;">
                            <div><div style="font-size:.55rem;color:#999;">Sv%</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${Sv_pct}%</div></div>
                            <div style="border-left:1px solid rgba(255,255,255,.1);border-right:1px solid rgba(255,255,255,.1);"><div style="font-size:.55rem;color:#999;">PDO</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${PDO}</div></div>
                            <div><div style="font-size:.55rem;color:#999;">Sh%</div><div style="font-size:1.1rem;font-weight:600;color:#fff;">${Sh_pct}%</div></div>
                        </div>
                    </div>
                </div>
            `;
        }

        async function renderGameReportShotmap(data){
            const attemptsArr = Array.isArray(data) ? data : (data && data.attempts) ? data.attempts : null;
            
            // Clear canvases if no data
            if(!attemptsArr || attemptsArr.length===0){
                const canvasDef = document.getElementById('defShotCanvas');
                const canvasOff = document.getElementById('offShotCanvas');
                if(canvasDef){
                    const ctx = setupCanvas(canvasDef);
                    ctx.clearRect(0, 0, canvasDef.width, canvasDef.height);
                }
                if(canvasOff){
                    const ctx = setupCanvas(canvasOff);
                    ctx.clearRect(0, 0, canvasOff.width, canvasOff.height);
                }
                return;
            }
            
            // Draw rink bases
            await drawRinkBases();
            
            // Get selected team from Perspective slicer
            const perspectiveSelect = document.getElementById('grPerspective');
            const forTeam = perspectiveSelect ? perspectiveSelect.value : '';
            
            // Draw shot markers
            await drawShotMarkers(attemptsArr, forTeam);
        }

        function renderGameReportTable(rows){
            const cont=document.getElementById('gamereport-table');
            if(!rows||!rows.length){ cont.innerHTML='<div style="opacity:0.6;font-size:.85rem;padding:1rem;text-align:center;color:#b7b3cf;">No data available for the selected table type.</div>'; return; }
            const first=rows[0];
            const cols=Object.keys(first);
            const header=cols.map(c=>`<th style="padding:.5rem .55rem;text-align:left;font-size:.75rem;letter-spacing:.03em;font-weight:600;">${c}</th>`).join('');
            const body=rows.map(r=>`<tr style="border-bottom:1px solid rgba(255,255,255,.05);">${cols.map(c=>`<td style="padding:.45rem .55rem;font-size:.8rem;">${r[c]===null||r[c]===undefined?'':r[c]}</td>`).join('')}</tr>`).join('');
            const tableType = document.getElementById('grTable')?.value || 'data';
            cont.innerHTML=`<h4 style="margin:0 0 .75rem;font-size:1rem;font-weight:600;letter-spacing:.03em;color:#b9a7ff;text-transform:capitalize;">${tableType} Table</h4><div style="max-height:420px;overflow:auto;border:1px solid rgba(142,124,214,.25);border-radius:.65rem;background:rgba(19,13,46,.75);">\n<table style="width:100%;border-collapse:collapse;">\n<thead style="position:sticky;top:0;background:rgba(25,28,48,.92);backdrop-filter:blur(4px);z-index:10;"><tr style="border-bottom:1px solid rgba(255,255,255,.08);">${header}</tr></thead><tbody>${body}</tbody></table></div>`;
        }
        
        // Helper functions for drawing shot maps on canvas
        // Rink image helpers (matching report.html approach)
        function setupCanvas(c){ c.width=c.clientWidth; c.height=c.clientHeight; return c.getContext('2d'); }
        
        // Team color cache
        const teamColorCache = (function(){
            let colors = null;
            return async function(team){
                if(colors) return colors[team] || '#53b3ff';
                try{
                    const resp = await fetch('/Teams.csv');
                    if(resp.ok){
                        colors = {};
                        const txt = await resp.text();
                        const lines = txt.split(/\n/);
                        const header = lines.shift();
                        lines.forEach(l => {
                            const c = l.split(',');
                            if(c.length > 5){
                                colors[c[1]] = c[5];
                            }
                        });
                        return colors[team] || '#53b3ff';
                    }
                } catch(e) {}
                return '#53b3ff';
            };
        })();
        const RINK_SRC='/static/hockey-rink.png';
        let rinkImgPromise=null;
        function loadRink(){
            if(rinkImgPromise) return rinkImgPromise;
            rinkImgPromise=new Promise(res=>{
                const i=new Image();
                i.onload=()=>res(i);
                i.onerror=()=>{ console.error('Failed to load rink image'); res(null); };
                i.src=RINK_SRC;
            });
            return rinkImgPromise;
        }

        async function drawRinkBases(){
            const img = await loadRink();
            if(!img) return;
            
            const def = document.getElementById('defRinkBase');
            const off = document.getElementById('offRinkBase');
            if(!def || !off) return;
            
            const d = setupCanvas(def);
            const o = setupCanvas(off);
            
            d.clearRect(0, 0, def.width, def.height);
            o.clearRect(0, 0, off.width, off.height);
            
            const sw = img.naturalWidth;
            const sh = img.naturalHeight;
            const zoneW = sw * 0.375; // 37.5% of rink width for each zone
            
            // Draw defensive zone (left portion of rink)
            d.drawImage(img, 0, 0, zoneW, sh, 0, 0, def.width, def.height);
            
            // Draw offensive zone (right portion of rink)
            o.drawImage(img, sw - zoneW, 0, zoneW, sh, 0, 0, off.width, off.height);
        }
        
        async function drawShotMarkers(attempts, forTeam){
            const canvasDef = document.getElementById('defShotCanvas');
            const canvasOff = document.getElementById('offShotCanvas');
            
            if(!canvasDef || !canvasOff) return;
            
            // Setup canvases
            const ctxDef = setupCanvas(canvasDef);
            const ctxOff = setupCanvas(canvasOff);
            
            ctxDef.clearRect(0, 0, canvasDef.width, canvasDef.height);
            ctxOff.clearRect(0, 0, canvasOff.width, canvasOff.height);
            
            console.log('Drawing shots for team:', forTeam);
            console.log('Total attempts:', attempts.length);
            
            // Get team colors
            const teamColors = {};
            const uniqueTeams = [...new Set(attempts.map(a => a.team_for))];
            for(const team of uniqueTeams){
                teamColors[team] = await teamColorCache(team);
            }
            console.log('Team colors:', teamColors);
            
            let defCount = 0, offCount = 0;
            
            attempts.forEach(a => {
                if(a.adj_x == null || a.adj_y == null) return;
                
                const origX = parseFloat(a.adj_x);
                const origY = parseFloat(a.adj_y);
                
                // Determine if this is a shot FOR the selected team or AGAINST
                const isFor = a.team_for === forTeam;
                
                // Determine if the shot was in offensive zone for the shooting team
                // A shot is offensive if |x| > 25 (far from center)
                const isOffensiveShot = Math.abs(origX) > 25;
                
                // Transform coordinates relative to selected team
                // If it's for our team, keep sign; if against, flip sign
                const rawX = isFor ? origX : -origX;
                const rawY = isFor ? origY : -origY;
                
                // Debug first few shots
                if(defCount + offCount < 5){
                    console.log(`Shot ${defCount + offCount}:`, {
                        team_for: a.team_for,
                        isFor,
                        origX,
                        rawX,
                        isOffensiveShot,
                        willShowIn: (isOffensiveShot ? 'offensive' : 'defensive')
                    });
                }
                
                // Skip neutral zone (|x| < 25)
                if(!isOffensiveShot) return;
                
                // Determine which canvas based on whose shot it is
                // Selected team's shots ‚Üí offensive zone (right)
                // Opponent's shots ‚Üí defensive zone (left)
                let ctx, canvas, zx;
                if(isFor){
                    // Our team's shot - show in offensive zone
                    ctx = ctxOff;
                    canvas = canvasOff;
                    // Normalize to [0,1] using absolute coordinates
                    zx = (Math.abs(rawX) - 25) / 75;
                    offCount++;
                } else {
                    // Opponent's shot - show in defensive zone (flip x-axis)
                    ctx = ctxDef;
                    canvas = canvasDef;
                    // Flip x-axis for defensive zone by subtracting from 1
                    zx = 1 - ((Math.abs(rawX) - 25) / 75);
                    defCount++;
                }
                
                const zy = (42.5 - rawY) / 85;
                
                const px = zx * canvas.width;
                const py = zy * canvas.height;
                
                // Get team color
                const teamColor = teamColors[a.team_for] || '#53b3ff';
                
                // Determine marker type
                const event = a.event || '';
                
                ctx.save();
                ctx.fillStyle = teamColor;
                ctx.strokeStyle = teamColor;
                ctx.lineWidth = 1.5;
                
                if(event === 'Goal') {
                    // Star for goals in team color
                    ctx.beginPath();
                    ctx.moveTo(px, py - 5);
                    ctx.lineTo(px + 4.5, py + 5);
                    ctx.lineTo(px - 4.5, py + 1.5);
                    ctx.lineTo(px + 4.5, py + 1.5);
                    ctx.lineTo(px - 4.5, py + 5);
                    ctx.closePath();
                    ctx.fill();
                } else if(event === 'Shot') {
                    // Filled circle for shots
                    ctx.beginPath();
                    ctx.arc(px, py, 4, 0, Math.PI * 2);
                    ctx.fill();
                } else if(event === 'Miss') {
                    // Filled triangle for misses
                    ctx.beginPath();
                    ctx.moveTo(px, py - 5);
                    ctx.lineTo(px + 5, py + 5);
                    ctx.lineTo(px - 5, py + 5);
                    ctx.closePath();
                    ctx.fill();
                } else if(event === 'Block') {
                    // Filled square for blocks
                    ctx.fillRect(px - 4, py - 4, 8, 8);
                }
                
                ctx.restore();
            });
            
            console.log(`Defensive zone: ${defCount} shots, Offensive zone: ${offCount} shots`);
        }

        function formatGameSummary(data) {
            let html = '<div class="game-summary">';
            
            // Check if we have the expected homeTeam/visitingTeam structure
            if (data && data.homeTeam && data.visitingTeam) {
                // Get team logos from current game info
                const homeTeamLogo = window.currentGameInfo?.home_team_logo || '';
                const awayTeamLogo = window.currentGameInfo?.away_team_logo || '';
                
                // Home Team Lineup
                html += `<div class="section">
                    <h3 style="display: flex; align-items: center; gap: 0.75rem;">
                        ${homeTeamLogo ? `<img src="${homeTeamLogo}" alt="${window.currentGameInfo?.home_team || 'Home Team'}" style="width: 32px; height: 32px;">` : 'üè†'}
                        ${window.currentGameInfo?.home_team || data.homeTeam.name || 'Home Team'}
                    </h3>`;
                
                // Goalies
                if (data.homeTeam.goalies && Array.isArray(data.homeTeam.goalies)) {
                    html += '<h4>ü•Ö Goalies</h4><div class="roster-grid">';
                    data.homeTeam.goalies.forEach(player => {
                        const stats = player.stats || {};
                        const playerImage = player.playerImageURL || 'https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';
                        html += `<div class="player-card" style="display: flex; align-items: flex-start; gap: 1rem;">
                            <img src="${playerImage}" alt="${player.name}" onerror="this.onerror=null;this.src='https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';" style="width: 80px; height: 80px; border-radius: 0.375rem; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <strong>#${player.jersey || 'N/A'} ${player.name || 'Unknown'}</strong><br>
                                <small>${player.position || 'G'}${stats.timeOnIce ? ` | TOI: ${stats.timeOnIce}` : ''}</small><br>
                                ${stats.gamesPlayed ? `<small>GP: ${stats.gamesPlayed} | W: ${stats.wins || 0} | L: ${stats.losses || 0}</small><br>` : ''}
                                ${stats.shotsAgainst !== undefined ? `<small>SA: ${stats.shotsAgainst} | Sv%: ${stats.shotsAgainst > 0 ? ((stats.saves / stats.shotsAgainst * 100).toFixed(1) + '%') : 'N/A'}</small>` : ''}
                            </div>
                        </div>`;
                    });
                    html += '</div>';
                }
                
                // Skaters
                if (data.homeTeam.skaters && Array.isArray(data.homeTeam.skaters)) {
                    html += '<h4>üèí Skaters</h4><div class="roster-grid">';
                    data.homeTeam.skaters.forEach(player => {
                        const stats = player.stats || {};
                        const playerImage = player.playerImageURL || 'https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';
                        html += `<div class="player-card" style="display: flex; align-items: flex-start; gap: 1rem;">
                            <img src="${playerImage}" alt="${player.name}" onerror="this.onerror=null;this.src='https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';" style="width: 80px; height: 80px; border-radius: 0.375rem; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <strong>#${player.jersey || 'N/A'} ${player.name || 'Unknown'}</strong><br>
                                <small>${player.position || 'Skater'}${stats.toi ? ` | TOI: ${stats.toi}` : ''}</small><br>
                                ${stats.goals !== undefined ? `<small>G: ${stats.goals} | A: ${stats.assists || 0} | P: ${stats.points || 0}</small><br>` : ''}
                                ${stats.plusMinus !== undefined || stats.penaltyMinutes !== undefined ? `<small>+/-: ${stats.plusMinus !== undefined ? (stats.plusMinus > 0 ? '+' + stats.plusMinus : stats.plusMinus) : 'N/A'} | PIM: ${stats.penaltyMinutes || 0}</small>` : ''}
                            </div>
                        </div>`;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
                
                // Visiting Team Lineup
                html += `<div class="section">
                    <h3 style="display: flex; align-items: center; gap: 0.75rem;">
                        ${awayTeamLogo ? `<img src="${awayTeamLogo}" alt="${window.currentGameInfo?.away_team || 'Visiting Team'}" style="width: 32px; height: 32px;">` : '‚úàÔ∏è'}
                        ${window.currentGameInfo?.away_team || data.visitingTeam.name || 'Visiting Team'}
                    </h3>`;
                
                // Goalies
                if (data.visitingTeam.goalies && Array.isArray(data.visitingTeam.goalies)) {
                    html += '<h4>ü•Ö Goalies</h4><div class="roster-grid">';
                    data.visitingTeam.goalies.forEach(player => {
                        const stats = player.stats || {};
                        const playerImage = player.playerImageURL || 'https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';
                        html += `<div class="player-card" style="display: flex; align-items: flex-start; gap: 1rem;">
                            <img src="${playerImage}" alt="${player.name}" onerror="this.onerror=null;this.src='https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';" style="width: 80px; height: 80px; border-radius: 0.375rem; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <strong>#${player.jersey || 'N/A'} ${player.name || 'Unknown'}</strong><br>
                                <small>${player.position || 'G'}${stats.timeOnIce ? ` | TOI: ${stats.timeOnIce}` : ''}</small><br>
                                ${stats.gamesPlayed ? `<small>GP: ${stats.gamesPlayed} | W: ${stats.wins || 0} | L: ${stats.losses || 0}</small><br>` : ''}
                                ${stats.shotsAgainst !== undefined ? `<small>SA: ${stats.shotsAgainst} | Sv%: ${stats.shotsAgainst > 0 ? ((stats.saves / stats.shotsAgainst * 100).toFixed(1) + '%') : 'N/A'}</small>` : ''}
                            </div>
                        </div>`;
                    });
                    html += '</div>';
                }
                
                // Skaters
                if (data.visitingTeam.skaters && Array.isArray(data.visitingTeam.skaters)) {
                    html += '<h4>üèí Skaters</h4><div class="roster-grid">';
                    data.visitingTeam.skaters.forEach(player => {
                        const stats = player.stats || {};
                        const playerImage = player.playerImageURL || 'https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';
                        html += `<div class="player-card" style="display: flex; align-items: flex-start; gap: 1rem;">
                            <img src="${playerImage}" alt="${player.name}" onerror="this.onerror=null;this.src='https://lscluster.hockeytech.com/statview-1.4.1/img/headshot-default.jpg';" style="width: 80px; height: 80px; border-radius: 0.375rem; flex-shrink: 0;">
                            <div style="flex: 1;">
                                <strong>#${player.jersey || 'N/A'} ${player.name || 'Unknown'}</strong><br>
                                <small>${player.position || 'Skater'}${stats.toi ? ` | TOI: ${stats.toi}` : ''}</small><br>
                                ${stats.goals !== undefined ? `<small>G: ${stats.goals} | A: ${stats.assists || 0} | P: ${stats.points || 0}</small><br>` : ''}
                                ${stats.plusMinus !== undefined || stats.penaltyMinutes !== undefined ? `<small>+/-: ${stats.plusMinus !== undefined ? (stats.plusMinus > 0 ? '+' + stats.plusMinus : stats.plusMinus) : 'N/A'} | PIM: ${stats.penaltyMinutes || 0}</small>` : ''}
                            </div>
                        </div>`;
                    });
                    html += '</div>';
                }
                
                html += '</div>';
            } 
            // Handle the case where API returns "Client access denied" or other errors
            else if (typeof data === 'string' && data.includes('denied')) {
                html += `<div class="section" style="text-align: center; padding: 2rem;">
                    <h3>üîí Lineup Data Currently Unavailable</h3>
                    <p style="color: #a0aec0; margin: 1rem 0;">
                        The PWHL lineup data is currently restricted by the API provider.
                    </p>
                    <p style="color: #a0aec0; margin: 1rem 0;">
                        We're working on alternative methods to provide team lineups including:
                    </p>
                    <ul style="text-align: left; max-width: 400px; margin: 1rem auto; color: #e2e8f0;">
                        <li>ü•Ö Goalie assignments</li>
                        <li>üèí Starting skater lineups</li>
                        <li>üìã Full roster information</li>
                        <li>üìä Player statistics</li>
                    </ul>
                    <p style="color: #4299e1; margin-top: 1.5rem;">
                        <strong>Play-by-Play data is still available!</strong>
                    </p>
                </div>`;
            }
            // Any other data structure - show for debugging
            else {
                html += '<div class="section">';
                html += '<h3>üìä Game Data</h3>';
                html += `<p style="color: #a0aec0; margin-bottom: 1rem;">Raw API response:</p>`;
                html += `<pre style="white-space: pre-wrap; font-size: 11px; overflow-x: auto; background-color: #1e2329; padding: 1rem; border-radius: 0.25rem; max-height: 400px; overflow-y: auto;">${JSON.stringify(data, null, 2)}</pre>`;
                html += '</div>';
            }
            
            html += '</div>';
            return html;
        }

        function formatPlayByPlay(data) {
            if (!Array.isArray(data) || data.length === 0) {
                return '<div style="text-align: center; padding: 2rem; color: #a0aec0;">No play-by-play data available.</div>';
            }

            const gameInfo = window.currentGameInfo || {};
            // Build lineup index for resolving shooter teams (used for shootout events)
            const lineupIndex = buildLineupIndex(window.currentGameSummaryData, gameInfo);

            // Build merged/filtered events to match CSV export logic
            const keyFor = (ev) => {
                const d = ev.details || {};
                const periodId = (d.period && (d.period.id || d.period.shortName)) || '';
                const time = d.time || '';
                return `${periodId}|${time}`;
            };
            const eventsByKey = new Map();
            data.forEach(ev => {
                const k = keyFor(ev);
                if (!eventsByKey.has(k)) eventsByKey.set(k, []);
                eventsByKey.get(k).push(ev);
            });
            const removedTypes = new Set(['goalie_change', 'goalie-change', 'hit', 'faceoff']);
            const consumed = new Set();
            const finalEvents = [];
            const ids1 = getGameTeamIds(gameInfo);
            const homeId = ids1.homeId;
            const awayId = ids1.awayId;

            data.forEach((ev, idx) => {
                if (consumed.has(idx)) return;
                const type = (ev.event || '').toLowerCase();
                if (removedTypes.has(type)) return;
                const d = ev.details || {};
                const key = keyFor(ev);
                if (type === 'goal') {
                    const goalTeamId = String(d.team?.id || '');
                    let shotEv = null;
                    const group = eventsByKey.get(key) || [];
                    for (const cand of group) {
                        if ((cand.event || '').toLowerCase() !== 'shot') continue;
                        const cd = cand.details || {};
                        if (String(cd.shooterTeamId || '') === goalTeamId) { shotEv = cand; break; }
                    }
                    if (shotEv) {
                        const shotIdx = data.indexOf(shotEv);
                        if (shotIdx >= 0) consumed.add(shotIdx);
                    }
                    const shotD = shotEv ? (shotEv.details || {}) : {};
                    finalEvents.push({
                        ...ev,
                        _computedTeamId: goalTeamId,
                        _mergedScorer: shotD.shooter || d.scoredBy || d.scorer || d.player || null,
                        _mergedAssists: Array.isArray(d.assists) ? d.assists.slice(0, 2) : [],
                        _mergedGoalie: shotD.goalie || d.goalie || null,
                        _x: (d.xLocation !== undefined ? d.xLocation : shotD.xLocation),
                        _y: (d.yLocation !== undefined ? d.yLocation : shotD.yLocation)
                    });
                    return;
                }
                if (type === 'shot') {
                    const shooterTeamId = String(d.shooterTeamId || d.teamId || d.team_id || '');
                    const group = eventsByKey.get(key) || [];
                    const hasMatchingGoal = group.some(g => {
                        if ((g.event || '').toLowerCase() !== 'goal') return false;
                        const gd = g.details || {};
                        return String(gd.team?.id || '') === shooterTeamId;
                    });
                    if (hasMatchingGoal) return;
                    finalEvents.push({ ...ev, _computedTeamId: shooterTeamId, _x: d.xLocation, _y: d.yLocation });
                    return;
                }
                if (type === 'shootout') {
                    const teamResolved = resolveShootoutTeamId(d, lineupIndex, gameInfo);
                    const soIsGoal = boolish(d?.isGoal) || boolish(d?.properties?.isGoal);
                    let teamIdForSO = teamResolved;
                    if (soIsGoal && d.scoredBy) {
                        const via = getPlayerTeamIdFromLineups(d.scoredBy, lineupIndex, gameInfo);
                        if (via) teamIdForSO = via;
                    }
                    finalEvents.push({ ...ev, _computedTeamId: String(teamIdForSO||''), _overrideEvent: soIsGoal ? 'SO_goal' : 'SO_miss' });
                    return;
                }
                if (type === 'penalty') {
                    // Per spec: againstTeam holds the team taking the penalty
                    let commitId = String(d.againstTeam?.id || '');
                    if (!commitId && d.againstTeam?.abbreviation) {
                        commitId = getTeamIdByAbbrev(d.againstTeam.abbreviation);
                    }
                    if (!commitId) {
                        const candidates = [d.team?.id, d.committingTeam?.id, d.penaltyTeam?.id, d.penalizedTeam?.id, d.offendingTeam?.id, d.teamId, d.team_id];
                        commitId = String(candidates.find(v => v !== undefined && v !== null && String(v) !== '') || '');
                    }
                    finalEvents.push({ ...ev, _computedTeamId: commitId });
                    return;
                }
                const computed = String(d.teamId || d.team_id || d.shooterTeamId || d.scorerTeamId || (d.team && d.team.id) || '');
                finalEvents.push({ ...ev, _computedTeamId: computed });
            });

            const escapeHTML = (s) => String(s ?? '').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
            const convertX = (x) => (x || x===0) ? (((x - 300) / 300 * 100).toFixed(1)) : '';
            const convertY = (y) => (y || y===0) ? (((y - 150) / 150 * 42.5).toFixed(1)) : '';

            let html = '<div class="play-by-play">';
            html += '<h3>‚ö° Play-by-Play</h3>';
            html += '<div class="pbp-scroll" style="overflow-x: auto; margin-top: 0.5rem;">';
            html += '<table class="pbp-table">';
            html += '<thead><tr>'+
                '<th class="pbp-col-right">id</th>'+
                '<th class="pbp-col-left">timestamp</th>'+
                '<th class="pbp-col-left">event</th>'+
                '<th class="pbp-col-left">team</th>'+
                '<th class="pbp-col-left">venue</th>'+
                '<th class="pbp-col-left">team_home</th>'+
                '<th class="pbp-col-left">team_away</th>'+
                '<th class="pbp-col-center">period</th>'+
                '<th class="pbp-col-left">perspective</th>'+
                '<th class="pbp-col-left">strength</th>'+
                '<th class="pbp-col-right">p1_no</th>'+
                '<th class="pbp-col-left">p1_name</th>'+
                '<th class="pbp-col-right">p2_no</th>'+
                '<th class="pbp-col-left">p2_name</th>'+
                '<th class="pbp-col-right">p3_no</th>'+
                '<th class="pbp-col-left">p3_name</th>'+
                '<th class="pbp-col-right">g_no</th>'+
                '<th class="pbp-col-left">goalie_name</th>'+
                '<th class="pbp-col-left">home_line</th>'+
                '<th class="pbp-col-left">home_players</th>'+
                '<th class="pbp-col-left">home_players_names</th>'+
                '<th class="pbp-col-left">away_line</th>'+
                '<th class="pbp-col-left">away_players</th>'+
                '<th class="pbp-col-left">away_players_names</th>'+
                '<th class="pbp-col-right">x</th>'+
                '<th class="pbp-col-right">y</th>'+
                '<th class="pbp-col-right">game_id</th>'+
                '<th class="pbp-col-left">game_date</th>'+
                '<th class="pbp-col-left">competition</th>'+
                '<th class="pbp-col-left">season</th>'+
                '<th class="pbp-col-left">state</th>'+
            '</tr></thead><tbody>';

            let idCounter = 1;
            // Ensure shootout events have teams; alternate if some are missing
            fixShootoutTeams(finalEvents, gameInfo);
            const strengths = computeStrengths(finalEvents, gameInfo);
            finalEvents.forEach((ev, idx) => {
                const details = ev.details || {};
                const eventType = getEventLabel(ev);
                const displayEventType = prettifyEventLabel(eventType);
                const teamId = String(ev._computedTeamId || '');
                let teamName = getTeamNameById(teamId) || (details.team && (details.team.name || details.team.fullName)) || '';
                if (!teamName) {
                    // Fallback by comparing with known game team names when IDs are missing
                    if (teamId && teamId === String(gameInfo.home_team_id || '')) teamName = gameInfo.home_team || '';
                    else if (teamId && teamId === String(gameInfo.away_team_id || '')) teamName = gameInfo.away_team || '';
                }
                let isHome = teamId === String(gameInfo.home_team_id || '');
                if (!String(gameInfo.home_team_id || '')) {
                    // Fallback when IDs are unavailable: compare names
                    if (teamName && gameInfo.home_team && teamName.toLowerCase() === String(gameInfo.home_team).toLowerCase()) isHome = true;
                    else if (teamName && gameInfo.away_team && teamName.toLowerCase() === String(gameInfo.away_team).toLowerCase()) isHome = false;
                }
                const venue = isHome ? 'Home' : 'Away';

                // players
                let p1_no='',p1_name='',p2_no='',p2_name='',p3_no='',p3_name='',g_no='',goalie_name='';
                if (eventType === 'goal') {
                    const scorer = ev._mergedScorer || details.scoredBy || details.scorer || details.player;
                    if (scorer) { p1_no = scorer.jerseyNumber || scorer.id || ''; p1_name = `${scorer.firstName||''} ${scorer.lastName||''}`.trim(); }
                    const assists = Array.isArray(ev._mergedAssists) ? ev._mergedAssists : (Array.isArray(details.assists) ? details.assists : []);
                    if (assists[0]) { p2_no = assists[0].jerseyNumber || assists[0].id || ''; p2_name = `${assists[0].firstName||''} ${assists[0].lastName||''}`.trim(); }
                    if (assists[1]) { p3_no = assists[1].jerseyNumber || assists[1].id || ''; p3_name = `${assists[1].firstName||''} ${assists[1].lastName||''}`.trim(); }
                    const gsrc = ev._mergedGoalie || details.goalie; if (gsrc) { g_no = gsrc.jerseyNumber || gsrc.id || ''; goalie_name = `${gsrc.firstName||''} ${gsrc.lastName||''}`.trim(); }
                } else if (eventType === 'penalty') {
                    const penaltyTaker = details.takenBy || details.player || details.servedBy; if (penaltyTaker) { p1_no = penaltyTaker.jerseyNumber || penaltyTaker.id || ''; p1_name = `${penaltyTaker.firstName||''} ${penaltyTaker.lastName||''}`.trim(); }
                    const penaltyDrawer = details.drawnBy; if (penaltyDrawer) { p2_no = penaltyDrawer.jerseyNumber || penaltyDrawer.id || ''; p2_name = `${penaltyDrawer.firstName||''} ${penaltyDrawer.lastName||''}`.trim(); }
                } else {
                    const player = details.shooter || details.player; if (player) { p1_no = player.jerseyNumber || player.id || ''; p1_name = `${player.firstName||''} ${player.lastName||''}`.trim(); }
                    if (details.goalie) { g_no = details.goalie.jerseyNumber || details.goalie.id || ''; goalie_name = `${details.goalie.firstName||''} ${details.goalie.lastName||''}`.trim(); }
                }

                // On-ice players from plus/minus style fields
                const toList = (arr) => (Array.isArray(arr) ? arr.map(p => {
                    if (p && typeof p === 'object') return (p.jerseyNumber||p.id||'');
                    return String(p||'');
                }).filter(Boolean) : []);
                const toNames = (arr) => (Array.isArray(arr) ? arr.map(p => {
                    if (p && typeof p === 'object') return `${p.firstName||''} ${p.lastName||''}`.trim();
                    return String(p||'');
                }).filter(Boolean) : []);
                // Prefer snake_case plus_players/minus_players when present
                const plusPlayers = details.plus_players || details.plusPlayers || details.homePlayers || details.homeOnIce || [];
                const minusPlayers = details.minus_players || details.minusPlayers || details.awayPlayers || details.awayOnIce || [];
                const homePlayers = isHome ? plusPlayers : minusPlayers;
                const awayPlayers = isHome ? minusPlayers : plusPlayers;
                const homePlayersNo = toList(homePlayers);
                const homePlayersNames = toNames(homePlayers);
                const awayPlayersNo = toList(awayPlayers);
                const awayPlayersNames = toNames(awayPlayers);

                let period = details.period ? (details.period.shortName || details.period.id || '') : '';
                if (eventType === 'SO_goal' || eventType === 'SO_miss') period = 'SO';
                const x = (ev._x !== undefined) ? ev._x : (details.xLocation !== undefined ? details.xLocation : details.xCoord);
                const y = (ev._y !== undefined) ? ev._y : (details.yLocation !== undefined ? details.yLocation : details.yCoord);

                const row = [
                    {v:idCounter++, cls:'pbp-col-right'},
                    {v:details.time||'', cls:'pbp-col-left'},
                    {v:displayEventType, cls:'pbp-col-left'},
                    {v:teamName, cls:'pbp-col-left'},
                    {v:venue, cls:'pbp-col-left'},
                    {v:gameInfo.home_team||'', cls:'pbp-col-left'},
                    {v:gameInfo.away_team||'', cls:'pbp-col-left'},
                    {v:period, cls:'pbp-col-center'},
                    {v:'event', cls:'pbp-col-left'},
                    {v: strengths[idx] || '', cls:'pbp-col-left'},
                    {v:p1_no, cls:'pbp-col-right'},
                    {v:p1_name, cls:'pbp-col-left'},
                    {v:p2_no, cls:'pbp-col-right'},
                    {v:p2_name, cls:'pbp-col-left'},
                    {v:p3_no, cls:'pbp-col-right'},
                    {v:p3_name, cls:'pbp-col-left'},
                    {v:g_no, cls:'pbp-col-right'},
                    {v:goalie_name, cls:'pbp-col-left'},
                    {v:'', cls:'pbp-col-left'},
                    {v:homePlayersNo.join(' '), cls:'pbp-col-left'},
                    {v:homePlayersNames.join(' - '), cls:'pbp-col-left'},
                    {v:'', cls:'pbp-col-left'},
                    {v:awayPlayersNo.join(' '), cls:'pbp-col-left'},
                    {v:awayPlayersNames.join(' - '), cls:'pbp-col-left'},
                    {v:convertX(x), cls:'pbp-col-right'},
                    {v:convertY(y), cls:'pbp-col-right'},
                    {v:gameInfo.game_id||'', cls:'pbp-col-right'},
                    {v:normalizeGameDate(gameInfo.date, gameInfo.season_year), cls:'pbp-col-left'},
                    {v:'PWHL', cls:'pbp-col-left'},
                    {v:gameInfo.season_year||'', cls:'pbp-col-left'},
                    {v:gameInfo.season_state||'', cls:'pbp-col-left'}
                ];
                html += '<tr>' + row.map(c => `<td class="${c.cls}">${escapeHTML(c.v)}</td>`).join('') + '</tr>';
            });

            html += '</tbody></table></div></div>';
            return html;
        }

        // Build merged finalEvents and strengths from PBP + summary, for reuse in Game Report
        function buildFinalEventsFromPBP(data, summaryData, gameInfo){
            const lineupIndex = buildLineupIndex(summaryData, gameInfo);
            const keyFor = (ev) => {
                const d = ev.details || {};
                const periodId = (d.period && (d.period.id || d.period.shortName)) || '';
                const time = d.time || '';
                return `${periodId}|${time}`;
            };
            const eventsByKey = new Map();
            data.forEach(ev => {
                const k = keyFor(ev);
                if (!eventsByKey.has(k)) eventsByKey.set(k, []);
                eventsByKey.get(k).push(ev);
            });
            const removedTypes = new Set(['goalie_change', 'goalie-change', 'hit', 'faceoff']);
            const consumed = new Set();
            const finalEvents = [];

            data.forEach((ev, idx) => {
                if (consumed.has(idx)) return;
                const type = (ev.event || '').toLowerCase();
                if (removedTypes.has(type)) return;
                const d = ev.details || {};
                const key = keyFor(ev);
                if (type === 'goal') {
                    const goalTeamId = String(d.team?.id || '');
                    let shotEv = null;
                    const group = eventsByKey.get(key) || [];
                    for (const cand of group) {
                        if ((cand.event || '').toLowerCase() !== 'shot') continue;
                        const cd = cand.details || {};
                        if (String(cd.shooterTeamId || '') === goalTeamId) { shotEv = cand; break; }
                    }
                    if (shotEv) {
                        const shotIdx = data.indexOf(shotEv);
                        if (shotIdx >= 0) consumed.add(shotIdx);
                    }
                    const shotD = shotEv ? (shotEv.details || {}) : {};
                    finalEvents.push({
                        ...ev,
                        _computedTeamId: goalTeamId,
                        _mergedScorer: shotD.shooter || d.scoredBy || d.scorer || d.player || null,
                        _mergedAssists: Array.isArray(d.assists) ? d.assists.slice(0, 2) : [],
                        _mergedGoalie: shotD.goalie || d.goalie || null,
                        _x: (d.xLocation !== undefined ? d.xLocation : shotD.xLocation),
                        _y: (d.yLocation !== undefined ? d.yLocation : shotD.yLocation)
                    });
                    return;
                }
                if (type === 'shot') {
                    const shooterTeamId = String(d.shooterTeamId || d.teamId || d.team_id || '');
                    const group = eventsByKey.get(key) || [];
                    const hasMatchingGoal = group.some(g => {
                        if ((g.event || '').toLowerCase() !== 'goal') return false;
                        const gd = g.details || {};
                        return String(gd.team?.id || '') === shooterTeamId;
                    });
                    if (hasMatchingGoal) return;
                    finalEvents.push({ ...ev, _computedTeamId: shooterTeamId, _x: d.xLocation, _y: d.yLocation });
                    return;
                }
                if (type === 'shootout') {
                    const teamResolved = resolveShootoutTeamId(d, lineupIndex, gameInfo);
                    const soIsGoal = boolish(d?.isGoal) || boolish(d?.properties?.isGoal);
                    let teamIdForSO = teamResolved;
                    if (soIsGoal && d.scoredBy) {
                        const via = getPlayerTeamIdFromLineups(d.scoredBy, lineupIndex, gameInfo);
                        if (via) teamIdForSO = via;
                    }
                    finalEvents.push({ ...ev, _computedTeamId: String(teamIdForSO||''), _overrideEvent: soIsGoal ? 'SO_goal' : 'SO_miss' });
                    return;
                }
                if (type === 'penalty') {
                    let commitId = String(d.againstTeam?.id || '');
                    if (!commitId && d.againstTeam?.abbreviation) {
                        commitId = getTeamIdByAbbrev(d.againstTeam.abbreviation);
                    }
                    if (!commitId) {
                        const candidates = [d.team?.id, d.committingTeam?.id, d.penaltyTeam?.id, d.penalizedTeam?.id, d.offendingTeam?.id, d.teamId, d.team_id];
                        commitId = String(candidates.find(v => v !== undefined && v !== null && String(v) !== '') || '');
                    }
                    finalEvents.push({ ...ev, _computedTeamId: commitId });
                    return;
                }
                if (type === 'blocked-shot' || type === 'blocked_shot' || type === 'block') {
                    // Orient by SHOOTING team
                    let shooterTid = String(d.againstTeam?.id || d.shooterTeamId || '');
                    if (!shooterTid && d.againstTeam?.abbreviation) shooterTid = getTeamIdByAbbrev(d.againstTeam.abbreviation);
                    if (!shooterTid && d.goalie) {
                        const goalieTid = getPlayerTeamIdFromLineups(d.goalie, lineupIndex, gameInfo);
                        if (goalieTid) {
                            const ids = getGameTeamIds(gameInfo);
                            shooterTid = goalieTid === ids.homeId ? ids.awayId : ids.homeId;
                        }
                    }
                    finalEvents.push({ ...ev, _computedTeamId: String(shooterTid||''), _x: d.xLocation, _y: d.yLocation });
                    return;
                }
                const computed = String(d.teamId || d.team_id || d.shooterTeamId || d.scorerTeamId || (d.team && d.team.id) || '');
                finalEvents.push({ ...ev, _computedTeamId: computed });
            });

            // Ensure shootout teams are filled/alternated
            fixShootoutTeams(finalEvents, gameInfo);
            const strengths = computeStrengths(finalEvents, gameInfo);
            return { finalEvents, strengths };
        }

        async function exportLineups() {
            if (!window.currentGameInfo) { alert('No lineup data available to export.'); return; }
            try {
                const resp = await fetch(`/api/export/lineups/${currentGameId}.csv`, { cache: 'no-store' });
                if (!resp.ok) throw new Error('Failed to fetch CSV');
                const csvText = await resp.text();
                await downloadCSV(csvText, `${currentGameId}_teams.csv`, { includeBOM: false });
            } catch (e) {
                console.error('Export lineups failed, falling back to in-browser generator:', e);
                alert('Unable to export via server. Please try again.');
            }
        }

        async function exportPlayByPlay() {
            if (!window.currentGameInfo) { alert('No play-by-play data available to export.'); return; }
            try {
                const resp = await fetch(`/api/export/pbp/${currentGameId}.csv`, { cache: 'no-store' });
                if (!resp.ok) throw new Error('Failed to fetch CSV');
                const csvText = await resp.text();
                await downloadCSV(csvText, `${currentGameId}_shots.csv`, { includeBOM: false });
            } catch (e) {
                console.error('Export PBP failed, please try again:', e);
                alert('Unable to export via server. Please try again.');
            }
        }

        // Shared date normalizer for yyyy-mm-dd using season logic
        function normalizeGameDate(dateStr, seasonYear) {
            if (!dateStr) return '';
            const iso = String(dateStr).match(/^(\d{4})-(\d{2})-(\d{2})/);
            if (iso) return `${iso[1]}-${iso[2]}-${iso[3]}`;
            const monthMap = {jan:1,january:1,feb:2,february:2,mar:3,march:3,apr:4,april:4,may:5,jun:6,june:6,jul:7,july:7,aug:8,august:8,sep:9,sept:9,september:9,oct:10,october:10,nov:11,november:11,dec:12,december:12};
            const parts = (seasonYear || '').split('/');
            const y1 = parseInt(parts[0],10); const y2 = parseInt(parts[1],10);
            const m = String(dateStr).match(/(Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|Aug(?:ust)?|Sep(?:t|tember)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?)\s+(\d{1,2})/i);
            if (m) {
                const month = monthMap[m[1].toLowerCase()];
                const day = parseInt(m[2],10);
                let year = (month>=8&&month<=12)?y1:y2;
                if (!isFinite(year)) year = new Date().getFullYear();
                return `${year}-${String(month).padStart(2,'0')}-${String(day).padStart(2,'0')}`;
            }
            try { const d = new Date(dateStr); if (!isNaN(d.getTime())) return d.toISOString().split('T')[0]; } catch {}
            return String(dateStr);
        }

        // Helper: parse TOI strings like MM:SS or HH:MM:SS into total seconds
        function toiToSeconds(toiVal) {
            if (toiVal === null || toiVal === undefined) return '';
            if (typeof toiVal === 'number' && isFinite(toiVal)) return Math.max(0, Math.floor(toiVal));
            const s = String(toiVal).trim();
            if (!s) return '';
            const parts = s.split(':').map(x => parseInt(x, 10));
            if (parts.some(n => isNaN(n))) {
                const n = parseInt(s, 10);
                return isNaN(n) ? '' : Math.max(0, n);
            }
            if (parts.length === 3) {
                const [hh, mm, ss] = parts;
                return (hh * 3600) + (mm * 60) + ss;
            }
            if (parts.length === 2) {
                const [mm, ss] = parts;
                return (mm * 60) + ss;
            }
            return parts[0] || 0;
        }

        function formatPlayerRow(player, teamName, teamColor, gameInfo, isHomeTeam) {
            const escapeCSV = (str) => {
                if (typeof str !== 'string') str = String(str || '');
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };

            const stats = player?.stats || {};
            const toiRaw = stats.timeOnIce || stats.toi || '';
            const toi = toiToSeconds(toiRaw);

            return [
                escapeCSV(player.jersey || ''),
                escapeCSV(player.name || ''),
                escapeCSV(player.position || ''), // Line = Position
                escapeCSV(isHomeTeam ? 'Home' : 'Away'), // Venue = Home or Away
                escapeCSV(teamName),
                escapeCSV(teamColor),
                escapeCSV(gameInfo.game_id),
                escapeCSV(normalizeGameDate(gameInfo.date, gameInfo.season_year)),
                escapeCSV('PWHL'),
                escapeCSV(gameInfo.season_year),
                escapeCSV(gameInfo.season_state),
                escapeCSV(toi)
            ].join(',') + '\n';
        }

    function formatPlayByPlayRow(event, id, gameInfo, strengthOverride='') {
            const escapeCSV = (str) => {
                if (typeof str !== 'string') str = String(str || '');
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    return '"' + str.replace(/"/g, '""') + '"';
                }
                return str;
            };

            // Convert coordinates from PWHL scale to shotplotter scale
            const convertX = (x) => {
                if (!x && x !== 0) return '';
                // Convert from 0-600 to -100 to +100
                return ((x - 300) / 300 * 100).toFixed(1);
            };

            const convertY = (y) => {
                if (!y && y !== 0) return '';
                // Convert from 0-300 to -42.5 to +42.5
                return ((y - 150) / 150 * 42.5).toFixed(1);
            };

            // date normalizer is shared: normalizeGameDate()

            const details = event.details || {};
            const eventKey = getEventLabel(event); // raw key (e.g., 'goal', 'shot', 'penalty', 'blocked-shot')
            const eventType = prettifyEventLabel(eventKey); // display for CSV
            // prefer precomputed team id if available
            const eventTeamId = (event._computedTeamId !== undefined) ? String(event._computedTeamId) : String(details.teamId || details.team_id || details.shooterTeamId || details.scorerTeamId || details.team?.id || '');
            let eventTeamName = getTeamNameById(eventTeamId) || (details.team && (details.team.name || details.team.fullName)) || '';
            if (!eventTeamName) {
                if (eventTeamId && eventTeamId === String(gameInfo.home_team_id || '')) eventTeamName = gameInfo.home_team || '';
                else if (eventTeamId && eventTeamId === String(gameInfo.away_team_id || '')) eventTeamName = gameInfo.away_team || '';
                else eventTeamName = eventTeamId;
            }
            let isHomeTeam = eventTeamId === String(gameInfo.home_team_id || '');
            if (!String(gameInfo.home_team_id || '')) {
                if (eventTeamName && gameInfo.home_team && eventTeamName.toLowerCase() === String(gameInfo.home_team).toLowerCase()) isHomeTeam = true;
                else if (eventTeamName && gameInfo.away_team && eventTeamName.toLowerCase() === String(gameInfo.away_team).toLowerCase()) isHomeTeam = false;
            }
            
            // Determine venue (Home/Away from event team perspective)
            const venue = isHomeTeam ? 'Home' : 'Away';
            
            // Extract player information based on event type
            let p1_no = '', p1_name = '', p2_no = '', p2_name = '', p3_no = '', p3_name = '';
            let g_no = '', goalie_name = '';
            
            if (eventKey === 'goal') {
                // Merge scorer from shot if present
                const scorer = event._mergedScorer || details.scoredBy || details.scorer || details.player;
                if (scorer) {
                    p1_no = scorer.jerseyNumber || scorer.id || '';
                    p1_name = `${scorer.firstName || ''} ${scorer.lastName || ''}`.trim();
                }
                const assists = Array.isArray(event._mergedAssists) ? event._mergedAssists : (Array.isArray(details.assists) ? details.assists : []);
                if (assists[0]) {
                    p2_no = assists[0].jerseyNumber || assists[0].id || '';
                    p2_name = `${assists[0].firstName || ''} ${assists[0].lastName || ''}`.trim();
                }
                if (assists[1]) {
                    p3_no = assists[1].jerseyNumber || assists[1].id || '';
                    p3_name = `${assists[1].firstName || ''} ${assists[1].lastName || ''}`.trim();
                }
                const gsrc = event._mergedGoalie || details.goalie;
                if (gsrc) {
                    g_no = gsrc.jerseyNumber || gsrc.id || '';
                    goalie_name = `${gsrc.firstName || ''} ${gsrc.lastName || ''}`.trim();
                }
            } else if (eventKey === 'penalty') {
                // For penalties: Player 1 = takenBy (taker), Player 2 = drawnBy
                const penaltyTaker = details.takenBy || details.player || details.servedBy;
                if (penaltyTaker) {
                    p1_no = penaltyTaker.jerseyNumber || penaltyTaker.id || '';
                    p1_name = `${penaltyTaker.firstName || ''} ${penaltyTaker.lastName || ''}`.trim();
                }
                const penaltyDrawer = details.drawnBy;
                if (penaltyDrawer) {
                    p2_no = penaltyDrawer.jerseyNumber || penaltyDrawer.id || '';
                    p2_name = `${penaltyDrawer.firstName || ''} ${penaltyDrawer.lastName || ''}`.trim();
                }
            } else {
                // For other events, use players as they are
                const player = details.shooter || details.player;
                if (player) {
                    p1_no = player.jerseyNumber || player.id || '';
                    p1_name = `${player.firstName || ''} ${player.lastName || ''}`.trim();
                }
                
                if (details.goalie) {
                    g_no = details.goalie.jerseyNumber || details.goalie.id || '';
                    goalie_name = `${details.goalie.firstName || ''} ${details.goalie.lastName || ''}`.trim();
                }
            }

            let period = details.period ? details.period.shortName || details.period.id || '' : '';
            if (getEventLabel(event) === 'SO_goal' || getEventLabel(event) === 'SO_miss') period = 'SO';

            // Coordinates (merge goal coordinates with shot if needed)
            const x = (event._x !== undefined) ? event._x : (details.xLocation !== undefined ? details.xLocation : details.xCoord);
            const y = (event._y !== undefined) ? event._y : (details.yLocation !== undefined ? details.yLocation : details.yCoord);

            // On-ice players: derive from plus/minus style arrays
            const toList = (arr) => (Array.isArray(arr) ? arr.map(p => (p.jerseyNumber||p.id||'')).filter(Boolean) : []);
            const toNames = (arr) => (Array.isArray(arr) ? arr.map(p => `${p.firstName||''} ${p.lastName||''}`.trim()).filter(Boolean) : []);
            const plusPlayers = details.plusPlayers || details.homePlayers || details.homeOnIce || [];
            const minusPlayers = details.minusPlayers || details.awayPlayers || details.awayOnIce || [];
            const homePlayers = isHomeTeam ? plusPlayers : minusPlayers;
            const awayPlayers = isHomeTeam ? minusPlayers : plusPlayers;
            const homePlayersNo = toList(homePlayers).join(' ');
            const homePlayersNames = toNames(homePlayers).join(' | ');
            const awayPlayersNo = toList(awayPlayers).join(' ');
            const awayPlayersNames = toNames(awayPlayers).join(' | ');

            return [
                escapeCSV(id),
                escapeCSV(details.time || ''),
                escapeCSV(eventType || ''),
                escapeCSV(eventTeamName),
                escapeCSV(venue),
                escapeCSV(gameInfo.home_team),
                escapeCSV(gameInfo.away_team),
                escapeCSV(period),
                escapeCSV('event'), // perspective is always 'event'
                escapeCSV(strengthOverride || ''),
                escapeCSV(p1_no),
                escapeCSV(p1_name),
                escapeCSV(p2_no),
                escapeCSV(p2_name),
                escapeCSV(p3_no),
                escapeCSV(p3_name),
                escapeCSV(g_no),
                escapeCSV(goalie_name),
                escapeCSV(''), // home_line - not available
                escapeCSV(homePlayersNo),
                escapeCSV(homePlayersNames.replace(/\s*\|\s*/g, ' - ')),
                escapeCSV(''), // away_line - not available
                escapeCSV(awayPlayersNo),
                escapeCSV(awayPlayersNames.replace(/\s*\|\s*/g, ' - ')),
                escapeCSV(convertX(x)),
                escapeCSV(convertY(y)),
                escapeCSV(gameInfo.game_id),
                escapeCSV(normalizeGameDate(gameInfo.date, gameInfo.season_year)),
                escapeCSV('PWHL'),
                escapeCSV(gameInfo.season_year),
                escapeCSV(gameInfo.season_state)
            ].join(',') + '\n';
        }

        // Helpers for shootout handling and general parsing
        function boolish(v) {
            if (v === true || v === 1) return true;
            const s = String(v).toLowerCase();
            return s === '1' || s === 'true' || s === 'yes' || s === 'y' || s === 't';
        }

        function buildLineupIndex(summaryData, gameInfo) {
            const idx = { ids:{}, names:{}, namesLast:{}, homeNumbers:new Set(), awayNumbers:new Set() };
            const homeId = String(gameInfo.home_team_id || '') || getTeamIdByName(gameInfo.home_team || '');
            const awayId = String(gameInfo.away_team_id || '') || getTeamIdByName(gameInfo.away_team || '');
            const addPlayer = (p, teamId, isHome) => {
                if (!p) return;
                const pid = String(p.id || p.playerId || '').trim();
                if (pid) idx.ids[pid] = teamId;
                const first = String(p.firstName||'').trim();
                const last = String(p.lastName||'').trim();
                const full = `${first} ${last}`.trim();
                const normFull = normalizeName(full);
                const normLast = normalizeName(last);
                if (normFull) idx.names[normFull] = teamId;
                if (normLast) {
                    if (!idx.namesLast[normLast]) idx.namesLast[normLast] = new Set();
                    idx.namesLast[normLast].add(teamId);
                }
                const num = String(p.jerseyNumber || p.jersey || '').trim();
                if (num) (isHome ? idx.homeNumbers : idx.awayNumbers).add(num);
            };
            try {
                if (summaryData?.homeTeam) {
                    (summaryData.homeTeam.goalies||[]).forEach(p=>addPlayer(p, homeId, true));
                    (summaryData.homeTeam.skaters||[]).forEach(p=>addPlayer(p, homeId, true));
                }
                if (summaryData?.visitingTeam) {
                    (summaryData.visitingTeam.goalies||[]).forEach(p=>addPlayer(p, awayId, false));
                    (summaryData.visitingTeam.skaters||[]).forEach(p=>addPlayer(p, awayId, false));
                }
            } catch {}
            idx.homeId = homeId; idx.awayId = awayId;
            return idx;
        }

        function getPlayerTeamIdFromLineups(player, idx, gameInfo) {
            if (!idx || !player) return '';
            if (typeof player === 'object') {
                const pid = String(player.id || player.playerId || player.playerID || '').trim();
                // Hardcode: Marie-Philip Poulin (id=31) -> Montr√©al Victoire
                if (pid === '31') return getTeamIdByName('Montr√©al Victoire') || '3';
                if (pid && idx.ids[pid]) return idx.ids[pid];
                const rawName = player.name || player.fullName || `${player.firstName||''} ${player.lastName||''}`;
                const nameKey = normalizeName(rawName);
                if (nameKey && idx.names[nameKey]) return idx.names[nameKey];
                // Try last-name-only unique match (avoid collisions)
                const lastKey = normalizeName(player.lastName || rawName.split(' ').pop() || '');
                if (lastKey && idx.namesLast[lastKey]) {
                    const set = idx.namesLast[lastKey];
                    if (set.size === 1) { for (const t of set) return t; }
                }
                const num = String(player.jerseyNumber || player.jersey || '').trim();
                if (num) {
                    const inHome = idx.homeNumbers.has(num);
                    const inAway = idx.awayNumbers.has(num);
                    if (inHome && !inAway) return idx.homeId;
                    if (inAway && !inHome) return idx.awayId;
                }
            } else if (typeof player === 'string' || typeof player === 'number') {
                const s = String(player).trim();
                const nameKey = normalizeName(s);
                if (nameKey && idx.names[nameKey]) return idx.names[nameKey];
                // Try last-name-only unique match
                const lastKey = normalizeName(String(s).split(' ').pop() || '');
                if (lastKey && idx.namesLast[lastKey]) {
                    const set = idx.namesLast[lastKey];
                    if (set.size === 1) { for (const t of set) return t; }
                }
                if (/^\d+$/.test(s)) {
                    const inHome = idx.homeNumbers.has(s);
                    const inAway = idx.awayNumbers.has(s);
                    if (inHome && !inAway) return idx.homeId;
                    if (inAway && !inHome) return idx.awayId;
                }
            }
            return '';
        }

        function getEventLabel(ev) {
            if (ev && ev._overrideEvent) return String(ev._overrideEvent);
            return String(ev?.event || '').toLowerCase();
        }

        // Map internal event keys to display labels for the UI table
        function prettifyEventLabel(key) {
            const k = String(key || '').toLowerCase();
            // Only override the specified events; leave others as-is
            if (k === 'goal') return 'Goal';
            if (k === 'shot') return 'Shot';
            if (k === 'penalty') return 'Penalty';
            if (k === 'blocked-shot' || k === 'blocked_shot' || k === 'block') return 'Block';
            // Keep shootout labels and other events unchanged
            return key;
        }

        function normalizeName(s) {
            if (!s) return '';
            return String(s)
                .normalize('NFD')
                .replace(/[\u0300-\u036f]/g, '')
                .toLowerCase()
                // normalize common punctuation/hyphens to spaces
                .replace(/[-‚Äô'`]/g, ' ')
                // collapse other whitespace
                .replace(/\s+/g, ' ')
                .trim();
        }

        // Resolve shootout shooter team leveraging multiple hints
        function resolveShootoutTeamId(details, lineupIndex, gameInfo) {
            const ids = getGameTeamIds(gameInfo);
            const canon = (tid, name, abbr) => {
                const t = String(tid||'').trim();
                if (t && (t === ids.homeId || t === ids.awayId)) return t;
                // try mapping via name/abbr
                if (abbr) {
                    const m = getTeamIdByAbbrev(abbr);
                    if (m) return m;
                }
                if (name) {
                    const m2 = getTeamIdByName(name);
                    if (m2) return m2;
                }
                return '';
            };
            // 1) Direct team info on event
            const direct = String(details.team?.id || details.teamId || details.team_id || '').trim();
            if (direct) {
                const c = canon(direct, details.team?.name || details.team?.fullName, details.team?.abbreviation);
                if (c) return c;
            }
            // 2) Shooter object via lineups (include scoredBy for SO_goal)
            const shooter = details.shooter || details.player || details.scoredBy || null;
            const viaLineups = getPlayerTeamIdFromLineups(shooter, lineupIndex, gameInfo);
            if (viaLineups) return viaLineups;
            // 2b) Try direct shooter identifiers
            const sid = String(details.shooterId || details.shooter_id || details.playerId || details.player_id || details.scorerId || details.scorer_id || '').trim();
            // Hardcode: Marie-Philip Poulin (id=31)
            if (sid === '31') return getTeamIdByName('Montr√©al Victoire') || '3';
            if (sid && lineupIndex.ids[sid]) return lineupIndex.ids[sid];
            const sname = normalizeName(details.shooterName || details.playerName || details.scorerName || '');
            if (sname && lineupIndex.names[sname]) return lineupIndex.names[sname];
            const sjersey = String(details.shooterJersey || details.jerseyNumber || details.scorerJersey || '').trim();
            if (sjersey) {
                const inHome = lineupIndex.homeNumbers.has(sjersey);
                const inAway = lineupIndex.awayNumbers.has(sjersey);
                if (inHome && !inAway) return lineupIndex.homeId;
                if (inAway && !inHome) return lineupIndex.awayId;
            }
            // 3) If goalie present, use opponent team
            const goalie = details.goalie || null;
            const goalieTeam = getPlayerTeamIdFromLineups(goalie, lineupIndex, gameInfo);
            if (goalie && goalieTeam) {
                return goalieTeam === ids.homeId ? ids.awayId : ids.homeId;
            }
            // 4) If team name/abbrev present
            const teamName = details.team?.name || details.team?.fullName || '';
            const abbr = details.team?.abbreviation;
            const mapped = canon('', teamName, abbr);
            if (mapped) return mapped;
            // 5) Last resort: empty
            return '';
        }

        // Fill missing shootout team IDs by alternating between home/away, starting from first known
        function fixShootoutTeams(finalEvents, gameInfo) {
            const ids = getGameTeamIds(gameInfo);
            const soIdxs = [];
            for (let i=0;i<finalEvents.length;i++) {
                const ev = finalEvents[i];
                const label = getEventLabel(ev);
                if (label === 'SO_goal' || label === 'SO_miss' || String(ev.event||'').toLowerCase()==='shootout') {
                    soIdxs.push(i);
                }
            }
            if (soIdxs.length === 0) return;
            // determine alternation from first two known entries if possible
            let startTeam = '';
            let secondTeam = '';
            for (const i of soIdxs) {
                const t = String(finalEvents[i]._computedTeamId||'').trim();
                if (t && (t===ids.homeId || t===ids.awayId)) {
                    if (!startTeam) startTeam = t; else if (!secondTeam && t!==startTeam) { secondTeam = t; break; }
                }
            }
            if (!startTeam) startTeam = ids.awayId; // default if not inferable
            if (!secondTeam) secondTeam = (startTeam===ids.homeId?ids.awayId:ids.homeId);
            let current = startTeam;
            const other = (t)=> t===ids.homeId ? ids.awayId : ids.homeId;
            for (const i of soIdxs) {
                const t = String(finalEvents[i]._computedTeamId||'').trim();
                if (!t) {
                    finalEvents[i]._computedTeamId = current;
                } else if (t === ids.homeId || t === ids.awayId) {
                    // snap to the alternation sequence: if provided team doesn't match current, flip current and keep provided
                    if (t !== current) current = t;
                } else {
                    // non-canonical, force canonical based on current
                    finalEvents[i]._computedTeamId = current;
                }
                current = other(current);
            }
        }

        // Compute Strength strings per event per the rules
        function computeStrengths(events, gameInfo) {
            // Normalize sort: by period index and time ascending
            const toSeconds = (t) => {
                if (!t) return 0;
                const m = String(t).split(':');
                const mm = parseInt(m[0]||'0',10); const ss = parseInt(m[1]||'0',10);
                return mm*60+ss;
            };
            const toBool = (v) => {
                if (v === true || v === 1) return true;
                const s = String(v).toLowerCase();
                return s === '1' || s === 'true' || s === 'yes' || s === 'y' || s === 't';
            };
            const parsePenaltySeconds = (minutesVal) => {
                if (minutesVal === undefined || minutesVal === null) return 120;
                if (typeof minutesVal === 'number') return Math.max(0, Math.round(minutesVal*60));
                const s = String(minutesVal).trim();
                if (/^\d+$/.test(s)) return parseInt(s,10)*60; // '2', '5'
                const m = s.match(/^(\d{1,2}):(\d{2})$/); // '2:00', '00:02'
                if (m) return parseInt(m[1],10)*60 + parseInt(m[2],10);
                return 120;
            };
            const isPenaltyShotEvent = (ev, d) => {
                const type=(ev.event||'').toLowerCase();
                if (type==='penalty shot') return true;
                const pt = (d.penaltyType||'').toLowerCase();
                return pt.includes('penalty shot');
            };
            const penaltyCreatesPP = (d) => {
                // Only root-level penalty flag determines manpower; ignore properties and duration
                if (toBool(d?.isPowerPlay)) return true;
                if (toBool(d?.is_power_play)) return true;
                return false;
            };
            const periodIndex = (d) => {
                const p = d.period ? (d.period.id || d.period.shortName) : '';
                const sp = String(p).toUpperCase();
                if (sp === '1' || sp === '2' || sp === '3') return parseInt(sp,10);
                if (sp === '4' || sp === 'OT' || sp.startsWith('OT')) return 4; // OT, OT1, OT2...
                if (sp === 'SO' || sp === 'SHOOTOUT') return 5;
                const n = parseInt(sp,10); return isFinite(n) ? n : 1;
            };
            const isRegularSeason = (gameInfo.season_state||'').toLowerCase() === 'regular season';

            // Copy and sort with original index
            const list = events.map((e,i)=>({e,i,pi:periodIndex(e.details||{}),ts:toSeconds((e.details||{}).time||'0:00')}))
                .sort((a,b)=> a.pi===b.pi ? (a.ts===b.ts ? a.i-b.i : a.ts-b.ts) : a.pi-b.pi);

            // Resolve team IDs robustly
            const ids0 = getGameTeamIds(gameInfo);
            const gameHomeId = ids0.homeId;
            const gameAwayId = ids0.awayId;

            // Active penalties: track array of {teamId, duration, endPi, endTs}; pending: penalties waiting to start due to 3-skater minimum
            const active = [];
            const pending = [];
            const resultsByIdx = {};
            const popExpired = (pi, ts) => {
                // Remove expired penalties
                for (let j = active.length - 1; j >= 0; j--) {
                    const p = active[j];
                    if (pi > p.endPi || (pi === p.endPi && ts >= p.endTs)) active.splice(j, 1);
                }
                // Try to start pending penalties if room is available (max 2 active against a team)
                if (pending.length) {
                    // Count active by team
                    const actByTeam = {};
                    for (const a of active) actByTeam[a.teamId] = (actByTeam[a.teamId] || 0) + 1;
                    for (let k = 0; k < pending.length; k++) {
                        const pen = pending[k];
                        const count = actByTeam[pen.teamId] || 0;
                        if (count < 2) {
                            // start now at current pi/ts
                            const started = computeEnd(pi, ts, pen.duration);
                            active.push({ teamId: pen.teamId, duration: pen.duration, endPi: started.endPi, endTs: started.endTs });
                            actByTeam[pen.teamId] = count + 1;
                            pending.splice(k, 1); k--;
                        }
                    }
                }
            };
            const computeEnd = (pi,ts,dur) => {
                let endPi = pi; let endTs = ts + dur;
                while (endTs >= 1200) { endTs -= 1200; endPi += 1; }
                return { endPi, endTs };
            };
            const addPenalty = (pi,ts,minutes,teamId) => {
                const dur = parseInt(minutes||'2',10)*60; // default 2 min
                const tId = String(teamId||'');
                // enforce max 2 simultaneous minors per team; queue extras
                const count = active.filter(p=>p.teamId===tId).length;
                if (count < 2) {
                    const end = computeEnd(pi, ts, dur);
                    active.push({ teamId: tId, duration: dur, endPi: end.endPi, endTs: end.endTs });
                } else {
                    pending.push({ teamId: tId, duration: dur });
                }
            };

            // Helper to see if any penalty affects a team
            const countAgainst = (teamId) => active.filter(p=>p.teamId===String(teamId||'')).length;

            // Iterate grouped by (period, time) so all events at same second share the same strength
            let ptr = 0;
            while (ptr < list.length) {
                const groupStart = ptr;
                const { pi, ts } = list[groupStart];
                // Expire penalties first for this timestamp
                popExpired(pi, ts);

                // Identify group end
                let groupEnd = groupStart + 1;
                while (groupEnd < list.length && list[groupEnd].pi === pi && list[groupEnd].ts === ts) groupEnd++;

                // Emit strengths for all rows in this group based on current active penalties
                for (let k = groupStart; k < groupEnd; k++) {
                    const row = list[k];
                    const ev = row.e; const d = ev.details||{}; const type=(ev.event||'').toLowerCase();
                    const teamId = String(ev._computedTeamId||'');

                    let homeBase=5, awayBase=5;
                    const isOT = (pi===4);
                    if (isOT && isRegularSeason) { homeBase=3; awayBase=3; }

                    if (isPenaltyShotEvent(ev, d) || d.isPenaltyShot===true || type==='shootout') {
                        resultsByIdx[row.i] = '1v0';
                        continue;
                    }

                    const homeId = String(gameHomeId||'');
                    const awayId = String(gameAwayId||'');
                    const homePens = countAgainst(homeId);
                    const awayPens = countAgainst(awayId);
                    if (isOT && isRegularSeason) {
                        // OT rule: add a skater to the non-penalized team, penalized stays at 3
                        homeBase = Math.min(5, 3 + awayPens);
                        awayBase = Math.min(5, 3 + homePens);
                    } else {
                        homeBase = Math.max(3, homeBase - homePens);
                        awayBase = Math.max(3, awayBase - awayPens);
                    }

                    const isHome = teamId && teamId === homeId;
                    const strengthStr = isHome ? `${homeBase}v${awayBase}` : `${awayBase}v${homeBase}`;
                    resultsByIdx[row.i] = strengthStr;
                }

                // Apply state changes after the entire timestamp group
                // 1) Add manpower penalties for qualifying penalties
                for (let k = groupStart; k < groupEnd; k++) {
                    const row = list[k];
                    const ev = row.e; const d = ev.details||{}; const type=(ev.event||'').toLowerCase();
                    if (type==='penalty') {
                        if (penaltyCreatesPP(d) && !isPenaltyShotEvent(ev, d)) {
                            const minutes = d.minutes || d.penaltyMinutes || 2;
                            let penalizedTeamId = String(d.againstTeam?.id || '');
                            if (!penalizedTeamId && d.againstTeam?.abbreviation) {
                                penalizedTeamId = getTeamIdByAbbrev(d.againstTeam.abbreviation);
                            }
                            if (!penalizedTeamId) penalizedTeamId = String(ev._computedTeamId||'');
                            if (penalizedTeamId) addPenalty(pi, ts, minutes, penalizedTeamId);
                        }
                    }
                }

                // 2) Expire penalties on PP/SH goals (but NOT 5-minute majors)
                for (let k = groupStart; k < groupEnd; k++) {
                    const row = list[k];
                    const ev = row.e; const d = ev.details||{}; const type=(ev.event||'').toLowerCase();
                    if (type==='goal') {
                        const teamId = String(ev._computedTeamId||'');
                        const homeId = String(gameHomeId||'');
                        const awayId = String(gameAwayId||'');
                        const isHome = teamId && teamId === homeId;
                        const isPP = toBool(d?.properties?.isPowerPlay) || toBool(d?.isPowerPlay) || toBool(d?.is_power_play);
                        const isSH = toBool(d?.properties?.isShortHanded) || toBool(d?.isShortHanded) || toBool(d?.is_short_handed);
                        if (isPP || isSH) {
                            const oppId = isHome ? awayId : homeId;
                            const idx = active.findIndex(p=>p.teamId===oppId && p.duration < 5*60);
                            if (idx>=0) active.splice(idx,1);
                        }
                    }
                }

                ptr = groupEnd;
            }

            // Map back to original order
            return events.map((_,i)=>resultsByIdx[i]||'');
        }

        function getTeamColor(teamName) {
            const teamColors = {
                'Boston Fleet': '#004D29',
                'Minnesota Frost': '#353364',
                'Montr√©al Victoire': '#8F001E',
                'New York Sirens': '#009E90',
                'Ottawa Charge': '#D1011B',
                'Toronto Sceptres': '#377BC2'
            };
            return teamColors[teamName] || '';
        }

        function getTeamNameById(teamId) {
            const teamMap = {
                '1': 'Boston Fleet',
                '2': 'Minnesota Frost',
                '3': 'Montr√©al Victoire',
                '4': 'New York Sirens',
                '5': 'Ottawa Charge',
                '6': 'Toronto Sceptres',
                '8': 'Seattle Torrent',
                '9': 'Vancouver Goldeneyes'
            };
            return teamMap[teamId] || '';
        }

        function getTeamIdByName(name) {
            if (!name) return '';
            const normalized = String(name).toLowerCase();
            const map = {
                'boston fleet':'1',
                'minnesota frost':'2',
                'montr√©al victoire':'3',
                'montreal victoire':'3',
                'new york sirens':'4',
                'ottawa charge':'5',
                'toronto sceptres':'6',
                'seattle torrent':'8',
                'pwhl seattle':'8',
                'vancouver goldeneyes':'9',
                'pwhl vancouver':'9'
            };
            return map[normalized] || '';
        }

        function getTeamIdByAbbrev(abbrev) {
            if (!abbrev) return '';
            const a = String(abbrev).toUpperCase();
            const map = { BOS:'1', MIN:'2', MTL:'3', NY:'4', OTT:'5', TOR:'6', SEA:'8', VAN:'9' };
            return map[a] || '';
        }

        function getGameTeamIds(gameInfo) {
            const homeId = String(gameInfo.home_team_id || '') || getTeamIdByName(gameInfo.home_team || '');
            const awayId = String(gameInfo.away_team_id || '') || getTeamIdByName(gameInfo.away_team || '');
            return { homeId, awayId };
        }

        async function downloadCSV(csvContent, filename, { includeBOM = false } = {}) {
            // Optionally prepend UTF-8 BOM (disabled by default to keep first header exactly "Number")
            const csvString = (includeBOM ? '\\ufeff' : '') + csvContent;
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8' });

            // Try modern Save As dialog (Chrome/Edge, secure context including localhost)
            try {
                if ('showSaveFilePicker' in window) {
                    const handle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{ description: 'CSV Files', accept: { 'text/csv': ['.csv'] } }]
                    });
                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();
                    return;
                }
            } catch (e) {
                console.warn('Save File Picker unavailable or failed; falling back to download.', e);
            }

            // Fallback: object URL + download attribute
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>