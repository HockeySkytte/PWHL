<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>PWHL Analytics ‚Äî Goalies</title>
  <style>
    :root { --pwhl-bg-1:#160A3A; --pwhl-bg-2:#251055; --pwhl-bg-3:#3B1E7A; --pwhl-surface:rgba(19,13,46,.75); --pwhl-surface-strong:rgba(25,16,60,.85); --pwhl-border:rgba(142,124,214,.25); --pwhl-accent:#8E7CD6; --pwhl-accent-strong:#B9A7FF; }
    body{margin:0;background:linear-gradient(135deg,var(--pwhl-bg-1),var(--pwhl-bg-2) 48%,var(--pwhl-bg-3));color:#fff;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;min-height:100vh;display:flex;flex-direction:column;}
    header{display:flex;justify-content:space-between;align-items:center;padding:1rem 2rem;border-bottom:1px solid var(--pwhl-border);background:var(--pwhl-surface-strong);} .brand{display:flex;align-items:center;gap:.75rem;font-weight:700;font-size:1.5rem;}
    .tabs{display:flex;background:var(--pwhl-surface-strong);border-bottom:1px solid var(--pwhl-border);} .tab{background:transparent;color:#d6d3e9;border:none;padding:1rem 2rem;cursor:pointer;border-bottom:3px solid transparent;transition:.2s;font-size:1.05rem;text-decoration:none;display:flex;align-items:center;gap:.4rem;font-weight:600;} .tab:hover{color:#fff;text-decoration:none;} .tab.active{color:var(--pwhl-accent-strong);border-bottom-color:var(--pwhl-accent-strong);}
    .container{display:grid;grid-template-columns:280px 1fr;gap:1rem;padding:1rem 2rem;}
    .panel{background:var(--pwhl-surface);border:1px solid var(--pwhl-border);border-radius:.75rem;padding:1rem;}
    .filters .dropdown{position:relative;margin-bottom:.75rem;}
    .filters .dropdown .dropdown-toggle{width:100%;padding:.5rem .6rem;border:1px solid #374151;background:#0f172a;color:#e5e7eb;border-radius:.4rem;text-align:left;}
    .filters .dropdown.open .dropdown-menu{display:block;}
    .filters .dropdown .dropdown-menu{position:absolute;top:110%;left:0;right:0;background:#0b1220;border:1px solid #374151;border-radius:.4rem;display:none;max-height:260px;overflow:auto;z-index:50;padding:.4rem;}
    .filters .search-box{margin-bottom:.45rem;}
    .filters .search-box input{width:100%;padding:.45rem .55rem;border:1px solid #374151;background:#0f172a;color:#e5e7eb;border-radius:.35rem;}
    .filters .option-list label{display:flex;align-items:center;gap:.5rem;padding:.35rem .25rem;}
    .hidden{display:none !important;}
    .label{font-size:.8rem;color:#9ca3af;margin-bottom:.25rem;}

    .filters .logo-section{margin-top:1rem;padding-top:1rem;border-top:1px solid var(--pwhl-border);text-align:center;}
    .filters .logo-link{display:inline-block;transition:opacity .2s;}
    .filters .logo-link:hover{opacity:.85;}
    .filters .logo-link img{width:120px;height:auto;border-radius:8px;}
    .filters .logo-attribution{margin-top:.6rem;font-size:.9rem;font-style:italic;color:rgba(255,255,255,.7);letter-spacing:.05em;}

    .ea-attribution{margin-top:.65rem;color:rgba(255,255,255,.7);font-size:1rem;}
    .ea-attribution a{color:var(--pwhl-accent-strong);text-decoration:none;font-weight:650;}
    .ea-attribution a:hover{text-decoration:underline;}
    .player-header{display:flex;align-items:center;gap:1rem;}
    .avatar{width:120px;height:120px;border-radius:.65rem;background:#111827;border:1px solid #374151;object-fit:cover;}
    .player-title{font-size:1.85rem;font-weight:700;}
    .player-meta{color:#9ca3af;font-size:1rem;margin-top:.15rem;}
    /* Sub-tabs under player header */
    .subtabs{display:flex;gap:.35rem;margin-top:.9rem;border-bottom:1px solid var(--pwhl-border);padding-bottom:.45rem;}
    .subtab{background:transparent;border:1px solid transparent;color:#d6d3e9;padding:.5rem .75rem;border-radius:.5rem;cursor:pointer;font-weight:650;}
    .subtab:hover{color:#fff;border-color:rgba(142,124,214,.25);}
    .subtab.active{color:var(--pwhl-accent-strong);border-color:rgba(142,124,214,.45);background:rgba(142,124,214,.10);}
    .subtab-panel{display:none;}
    .subtab-panel.active{display:block;}
    /* Compact cards: aim to fit 9 cards in one row on desktop */
    .stats-grid{display:grid;grid-template-columns:repeat(9, minmax(88px, 1fr));gap:.5rem;margin-top:1rem;}
    .stat-card{background:#0f172a;border:1px solid #374151;border-radius:.5rem;padding:.5rem .45rem;text-align:center;}
    .stat-card .value{font-size:1.1rem;font-weight:600;}
    @media (max-width: 1100px){
      .stats-grid{grid-template-columns:repeat(auto-fit, minmax(120px, 1fr));}
    }
    .stat-card .label{color:#9ca3af;font-size:.8rem;margin-bottom:.25rem;}
    .stat-card .value{font-size:1.2rem;font-weight:600;}
    .shot-area{display:grid;grid-template-columns:360px 1fr 1fr;gap:1rem;margin-top:1rem;align-items:start;}
    .goalie-table-wrap{background:#0f172a;border:1px solid #374151;border-radius:.5rem;overflow:hidden;}
    table{width:100%;border-collapse:collapse;font-size:.85rem;}
    thead th{position:sticky;top:0;background:#0b1220;color:#cbd5e1;text-align:left;padding:.55rem .6rem;border-bottom:1px solid #374151;}
    thead th.sortable{cursor:pointer;user-select:none;}
    thead th.sortable:hover{color:#ffffff;}
    tbody td{padding:.45rem .6rem;border-bottom:1px solid rgba(55,65,81,.55);color:#e5e7eb;}
    tbody tr{cursor:pointer;}
    tbody tr:hover{background:rgba(142,124,214,.12);}
    tbody tr.active{background:rgba(142,124,214,.22);}
    /* Offensive zone dimensions: 75 (wide) x 85 (high) */
    .rink-wrap{position:relative;width:100%;max-width:560px;aspect-ratio:75 / 85;}
    .rink-wrap canvas{display:block;width:100%;height:100%;border-radius:.5rem;border:1px solid var(--pwhl-border);}
    #heatRinkBase,#offRinkBase{background:#0d0d18;}
    #heatCanvas,#offShotCanvas{position:absolute;inset:0;background:transparent;border:none;}

    @media (max-width: 1200px){
      .shot-area{grid-template-columns:1fr;}
      .rink-wrap{max-width:720px;}
    }

    /* Performance chart */
    .perf-controls{display:flex;align-items:center;gap:.65rem;margin-top:1rem;}
    .perf-controls .label{margin:0;}
    .perf-controls select{padding:.45rem .55rem;border:1px solid #374151;background:#0f172a;color:#e5e7eb;border-radius:.4rem;}
    .perf-controls input{padding:.45rem .55rem;border:1px solid #374151;background:#0f172a;color:#e5e7eb;border-radius:.4rem;width:88px;}
    .perf-controls input:disabled{opacity:.55;}
    .perf-chart-wrap{margin-top:.75rem;background:#0f172a;border:1px solid #374151;border-radius:.5rem;padding:.75rem;}
    .perf-chart{width:100%;height:360px;display:block;}

    /* EA charts */
    .ea-charts{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin-top:1rem;align-items:start;}
    .ea-chart-wrap{background:#0f172a;border:1px solid #374151;border-radius:.5rem;padding:.75rem;}
    .ea-chart-controls{display:flex;align-items:center;gap:.55rem;margin:0 0 .55rem;}
    .ea-chart-controls .label{margin:0;color:#9ca3af;font-size:.8rem;}
    .ea-chart-controls select{padding:.4rem .5rem;border:1px solid #374151;background:#0f172a;color:#e5e7eb;border-radius:.4rem;}
    .ea-chart{width:100%;height:480px;display:block;}
    @media (max-width: 1200px){
      .ea-charts{grid-template-columns:1fr;}
      .ea-chart{height:480px;}
    }
  </style>
</head>
<body>
  <header>
    <div class="brand"><img src="/static/PWHL_logo.png" alt="PWHL" style="height:28px"> <span>PWHL Analytics</span></div>
  </header>
  <div class="tabs">
    <a class="tab" href="/">üìÖ Schedule</a>
    <a class="tab" href="/report">üìä Report</a>
    <a class="tab" href="/skaters">üèí Skaters</a>
    <a class="tab active" href="/goalies" aria-label="Goalies">
      <svg aria-hidden="true" viewBox="0 0 24 24" width="16" height="16" focusable="false" fill="none" stroke="#ffffff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
        <!-- Helmet outline -->
        <path d="M12 3c4.4 0 7.8 2.6 7.8 7.2 0 6-4.2 11-7.8 11.3C8.4 21.2 4.2 16.2 4.2 10.2 4.2 5.6 7.6 3 12 3z"/>
        <path d="M7.2 10.4c.1-3 2.1-5 4.8-5s4.7 2 4.8 5"/>
        <!-- Forehead pads -->
        <path d="M9 4.7h6"/>
        <path d="M8.1 6.2h1.4M14.5 6.2h1.4"/>
        <!-- Cage -->
        <path d="M8 11.2c1.2 1 2.7 1.6 4 1.6s2.8-.6 4-1.6"/>
        <path d="M8.2 13.1h7.6"/>
        <path d="M9.1 15h5.8"/>
        <path d="M12 10.6v5.2"/>
        <path d="M10.2 10.9v4.8"/>
        <path d="M13.8 10.9v4.8"/>
      </svg>
      Goalies
    </a>
    <a class="tab" href="/teams">üèüÔ∏è Teams</a>
    <a class="tab" href="/data">üóÇÔ∏è Data</a>
    <a class="tab" href="/coffee">‚òï Buy me a coffee</a>
  </div>
  <div class="container">
    <aside class="panel filters">
      <div class="label">Player</div>
      <div class="dropdown" id="playerDropdown">
        <button class="dropdown-toggle" id="playerToggle" type="button">Select Player</button>
        <div class="dropdown-menu" id="playerMenu"></div>
      </div>

      <div id="eaOnlyFilters" class="hidden">
        <div class="label">Game Version</div>
        <div class="dropdown" id="gameVersionDropdown">
          <button class="dropdown-toggle" id="gameVersionToggle" type="button">Select Game Version</button>
          <div class="dropdown-menu" id="gameVersionMenu"></div>
        </div>
      </div>

      <div id="nonEaFilters">
        <div class="label">Season</div>
        <div class="dropdown" id="seasonsDropdown"><button class="dropdown-toggle" type="button">Select Seasons</button><div class="dropdown-menu" id="seasonsMenu"></div></div>
        <div class="label">Season State</div>
        <div class="dropdown" id="season_statesDropdown"><button class="dropdown-toggle" type="button">Select Season State</button><div class="dropdown-menu" id="season_statesMenu"></div></div>
        <div class="label">Strength State</div>
        <div class="dropdown" id="strengthsDropdown"><button class="dropdown-toggle" type="button">Select Strength</button><div class="dropdown-menu" id="strengthsMenu"></div></div>
      </div>

      <div class="logo-section">
        <a href="https://hockey-statistics.com/" target="_blank" rel="noopener noreferrer" class="logo-link">
          <img src="{{ url_for('static', filename='Logo.png') }}" alt="Hockey Statistics Logo">
        </a>
        <div class="logo-attribution">App by HockeySkytte</div>
      </div>
    </aside>
    <main class="panel">
      <div class="player-header">
        <img id="playerAvatar" class="avatar" src="/static/Thumbnail.png" alt="Player">
        <div>
          <div id="playerName" class="player-title">‚Äî</div>
          <div id="playerMeta" class="player-meta">&nbsp;</div>
        </div>
      </div>
      <div class="stats-grid" id="goalieStatCards">
        <div class="stat-card"><div class="label">GP</div><div class="value" id="stat-gp">‚Äî</div></div>
        <div class="stat-card"><div class="label">TOI</div><div class="value" id="stat-toi">‚Äî</div></div>
        <div class="stat-card"><div class="label">SA</div><div class="value" id="stat-sa">‚Äî</div></div>
        <div class="stat-card"><div class="label">GA</div><div class="value" id="stat-ga">‚Äî</div></div>
        <div class="stat-card"><div class="label">Sv%</div><div class="value" id="stat-sv">‚Äî</div></div>
        <div class="stat-card"><div class="label">xGA</div><div class="value" id="stat-xga">‚Äî</div></div>
        <div class="stat-card"><div class="label">xSv%</div><div class="value" id="stat-xsv">‚Äî</div></div>
        <div class="stat-card"><div class="label">dSv%</div><div class="value" id="stat-dsv">‚Äî</div></div>
        <div class="stat-card"><div class="label">GSAx</div><div class="value" id="stat-gsax">‚Äî</div></div>
      </div>

      <div class="stats-grid hidden" id="eaCards">
        <div class="stat-card" data-ea-card><div class="label">Overall</div><div class="value" id="ea-overall">‚Äî</div></div>
        <div class="stat-card" data-ea-card><div class="label">Reflexes</div><div class="value" id="ea-reflexes">‚Äî</div></div>
        <div class="stat-card" data-ea-card><div class="label">Puck Control</div><div class="value" id="ea-puck-control">‚Äî</div></div>
        <div class="stat-card" data-ea-card><div class="label">Athletic</div><div class="value" id="ea-athletic">‚Äî</div></div>
      </div>

      <div class="subtabs" id="skaterTabs" role="tablist" aria-label="Goalies tabs">
        <button class="subtab" type="button" data-tab="ea" role="tab" aria-selected="false">EA Ratings</button>
        <button class="subtab active" type="button" data-tab="shooting" role="tab" aria-selected="true">Goaltending</button>
        <button class="subtab" type="button" data-tab="performance" role="tab" aria-selected="false">Performance</button>
      </div>

      <div id="tab-ea" class="subtab-panel">
        <div class="ea-charts">
          <div class="ea-chart-wrap">
            <div class="ea-chart-controls">
              <div class="label">Radar</div>
              <select id="eaRadarMode">
                <option value="grouped" selected>Grouped</option>
                <option value="detailed">Detailed</option>
              </select>
            </div>
            <canvas id="eaRadar" class="ea-chart"></canvas>
          </div>
          <div class="ea-chart-wrap">
            <div class="ea-chart-controls">
              <div class="label">Line Metric</div>
              <select id="eaLineMetric"></select>
            </div>
            <canvas id="eaOverallTrend" class="ea-chart"></canvas>
          </div>
        </div>
        <div class="ea-attribution">EA Ratings collected by <a href="https://x.com/jbouch95" target="_blank" rel="noopener noreferrer">@jbouch95</a></div>
        <div id="eaMessage" class="label" style="margin-top:.65rem">&nbsp;</div>
      </div>

      <div id="tab-shooting" class="subtab-panel active">
        <div class="shot-area">
          <div class="goalie-table-wrap">
            <table>
              <thead>
                <tr>
                  <th class="sortable" data-sort="Shooter" style="width:42%">Skater</th>
                  <th class="sortable" data-sort="Goals" style="width:10%">G</th>
                  <th class="sortable" data-sort="Shots" style="width:12%">S</th>
                  <th class="sortable" data-sort="xG" style="width:14%">xG</th>
                  <th class="sortable" data-sort="Sh%" style="width:12%">Sh%</th>
                  <th class="sortable" data-sort="GSAx" style="width:10%">GSAx</th>
                </tr>
              </thead>
              <tbody id="goalieTableBody"></tbody>
            </table>
          </div>
          <div>
            <h3 style="margin:0 0 .4rem">Heat Map</h3>
            <div class="rink-wrap">
              <canvas id="heatRinkBase"></canvas>
              <canvas id="heatCanvas"></canvas>
            </div>
          </div>
          <div>
            <h3 style="margin:0 0 .4rem">Shot Map</h3>
            <div class="rink-wrap">
              <canvas id="offRinkBase"></canvas>
              <canvas id="offShotCanvas"></canvas>
            </div>
          </div>
        </div>
      </div>

      <div id="tab-performance" class="subtab-panel">
        <div class="perf-controls">
          <div class="label" style="margin:0">Metric</div>
          <select id="perfMetric">
            <option value="GSAx" selected>GSAx</option>
            <option value="GA">GA</option>
            <option value="SA">SA</option>
            <option value="xGA">xGA</option>
            <option value="TOI">TOI</option>
          </select>
          <div class="label" style="margin:0 0 0 .25rem">Mode</div>
          <select id="perfMode">
            <option value="running" selected>Running Total</option>
            <option value="ma">Moving Average</option>
          </select>
          <div class="label" style="margin:0 0 0 .25rem">MA games</div>
          <input id="perfMaWindow" type="number" min="1" step="1" value="5" disabled>
          </select>
        </div>
        <div class="perf-chart-wrap">
          <canvas id="perfChart" class="perf-chart"></canvas>
        </div>
      </div>
    </main>
  </div>
  <script>
    // Dropdown helpers
    const multiIds=['seasons','season_states','strengths'];
    function getMultiValues(id){ return Array.from(document.querySelectorAll(`#${id}Menu input:checked`)).map(i=>i.value); }
    function buildMenu(id, items){ const menu=document.getElementById(id+'Menu'); if(!menu) return; menu.innerHTML='';
      const listWrap=document.createElement('div'); listWrap.className='option-list'; menu.appendChild(listWrap);
      listWrap.innerHTML=''; (items||[]).forEach(v=>{ const label=document.createElement('label'); const cb=document.createElement('input'); cb.type='checkbox'; cb.value=v.value||v; label.appendChild(cb); const span=document.createElement('span'); span.textContent=v.label||v; label.appendChild(span); listWrap.appendChild(label); });
    }
    function updateButtonLabel(id){ const selected=getMultiValues(id); const btn=document.querySelector(`#${id}Dropdown .dropdown-toggle`); if(!btn) return; if(selected.length===0){ btn.textContent=`Select ${id.replace(/_/g,' ')}`; } else if(selected.length===1){ btn.textContent=selected[0]; } else { btn.textContent=`${selected.length} selected`; } }
    function toggleDropdown(drop){ document.querySelectorAll('.dropdown').forEach(d=>{ if(d!==drop) d.classList.remove('open');}); drop.classList.toggle('open'); }
    document.addEventListener('click',e=>{ const dd=e.target.closest('.dropdown'); if(!dd) document.querySelectorAll('.dropdown').forEach(d=>d.classList.remove('open')); const tog=e.target.closest('.dropdown-toggle'); if(tog){ toggleDropdown(tog.parentElement); }});

    // Player dropdown (single select + search inside menu)
    let allPlayers=[];
    let selectedPlayer='';
    function setSelectedPlayer(name){ selectedPlayer = name || ''; document.getElementById('playerToggle').textContent = selectedPlayer || 'Select Player'; }

    // Persistence (Goalies page)
    const GOALIES_STATE_KEY = 'pwhl_goalies_state_v1';
    let pendingRestoreState = null;
    function safeJsonParse(s){ try{ return JSON.parse(s); }catch(e){ return null; } }
    function loadSkatersState(){
      try{ return safeJsonParse(localStorage.getItem(GOALIES_STATE_KEY) || ''); }catch(e){ return null; }
    }
    function saveSkatersState(){
      try{
        const radarModeSel = document.getElementById('eaRadarMode');
        const lineMetricSel = document.getElementById('eaLineMetric');
        const perfMetricSel = document.getElementById('perfMetric');
        const perfModeSel = document.getElementById('perfMode');
        const perfMaIn = document.getElementById('perfMaWindow');
        const state = {
          activeSkaterTab,
          selectedPlayer,
          selectedGameVersion,
          selectedEaLineMetric,
          eaRadarMode: radarModeSel ? radarModeSel.value : 'grouped',
          multi: {
            seasons: getMultiValues('seasons'),
            season_states: getMultiValues('season_states'),
            strengths: getMultiValues('strengths')
          },
          shooting: {
            selectedShooter,
            selectedZoneId
          },
          performance: {
            metric: perfMetricSel ? perfMetricSel.value : 'GSAx',
            mode: perfModeSel ? perfModeSel.value : 'running',
            maWindow: perfMaIn ? (Number(perfMaIn.value)||5) : 5
          },
          ea: {
            lineMetric: lineMetricSel ? lineMetricSel.value : selectedEaLineMetric
          }
        };
        localStorage.setItem(GOALIES_STATE_KEY, JSON.stringify(state));
      }catch(e){}
    }
    function applyMultiSelections(id, values){
      const set = new Set((values||[]).map(String));
      document.querySelectorAll(`#${id}Menu input[type=checkbox]`).forEach(cb=>{
        cb.checked = set.has(String(cb.value));
      });
      updateButtonLabel(id);
    }
    function buildPlayerMenu(players){
      const menu=document.getElementById('playerMenu');
      menu.innerHTML='';
      const searchWrap=document.createElement('div'); searchWrap.className='search-box';
      const search=document.createElement('input'); search.type='text'; search.placeholder='Search player...';
      searchWrap.appendChild(search); menu.appendChild(searchWrap);
      const listWrap=document.createElement('div'); listWrap.className='option-list'; menu.appendChild(listWrap);
      function render(q=''){
        listWrap.innerHTML='';
        const term=(q||'').trim().toLowerCase();
        const items = term ? (players||[]).filter(p=>String(p).toLowerCase().includes(term)) : (players||[]);
        items.forEach(n=>{
          const label=document.createElement('label');
          const rb=document.createElement('input'); rb.type='radio'; rb.name='playerRadio'; rb.value=n;
          rb.checked = (n===selectedPlayer);
          rb.addEventListener('change',()=>{
            setSelectedPlayer(n);
            document.getElementById('playerDropdown').classList.remove('open');
            setSelectedShooter('');
            setSelectedZone('');
            // When switching players, default the Game Version slicer to the newest available for that player.
            setSelectedGameVersion('');
            syncEaGameVersionsForPlayer();
            saveSkatersState();
            refreshActiveTab();
          });
          label.appendChild(rb);
          const span=document.createElement('span'); span.textContent=n; label.appendChild(span);
          listWrap.appendChild(label);
        });
      }
      search.addEventListener('input',()=>render(search.value));
      render('');
    }

    /** ---------------- EA Ratings (CSV-backed) ---------------- */
    let eaRows = null;
    let eaByPlayer = null; // Map<Name_PWHL, Map<Game Version, row>>
    let selectedGameVersion = '';
    let selectedEaLineMetric = 'Overall';

    function parseCsv(text){
      const rows=[];
      let cur=[];
      let field='';
      let inQuotes=false;

      function pushField(){ cur.push(field); field=''; }
      function pushRow(){
        if(cur.length===1 && String(cur[0]||'').trim()===''){ cur=[]; return; }
        rows.push(cur);
        cur=[];
      }

      for(let i=0;i<text.length;i++){
        const ch=text[i];
        if(inQuotes){
          if(ch==='"'){
            const next=text[i+1];
            if(next==='"'){ field+='"'; i++; }
            else { inQuotes=false; }
          } else {
            field+=ch;
          }
        } else {
          if(ch==='"') inQuotes=true;
          else if(ch===',') pushField();
          else if(ch==='\n'){ pushField(); pushRow(); }
          else if(ch==='\r'){ /* ignore */ }
          else field+=ch;
        }
      }
      pushField();
      pushRow();

      if(!rows.length) return [];
      // De-dupe headers (Goalies CSV currently contains duplicate columns like "Overall")
      const rawHeader = rows[0].map(h=>String(h||'').trim());
      const seen = new Map();
      const header = rawHeader.map((h)=>{
        const key = h || '';
        const n = (seen.get(key) || 0) + 1;
        seen.set(key, n);
        return n === 1 ? key : `${key}__${n}`;
      });
      const out=[];
      for(let r=1;r<rows.length;r++){
        const obj={};
        for(let c=0;c<header.length;c++) obj[header[c]] = rows[r][c] != null ? String(rows[r][c]) : '';
        out.push(obj);
      }
      return out;
    }

    async function loadEaRows(){
      if(eaRows) return eaRows;
      try{
        const resp = await fetch('/static/EA_Sports_Goalies.csv');
        if(!resp.ok) return null;
        const txt = await resp.text();
        eaRows = parseCsv(txt);
      }catch(e){ eaRows = null; }

      if(!eaRows) return null;
      eaByPlayer = new Map();
      for(const row of eaRows){
        const player = String(row['Name_PWHL']||'').trim();
        const ver = String(row['Game Version']||'').trim();
        if(!player || !ver) continue;
        if(!eaByPlayer.has(player)) eaByPlayer.set(player, new Map());
        const verMap = eaByPlayer.get(player);
        if(!verMap.has(ver)) verMap.set(ver, row);
      }
      return eaRows;
    }

    function eaPlayersList(){
      if(!eaByPlayer) return [];
      return Array.from(eaByPlayer.keys()).sort((a,b)=>a.localeCompare(b));
    }

    function compareGameVersions(a, b){
      const A = String(a ?? '');
      const B = String(b ?? '');
      if(A === B) return 0;
      const aParts = A.match(/\d+|\D+/g) || [A];
      const bParts = B.match(/\d+|\D+/g) || [B];
      const n = Math.max(aParts.length, bParts.length);
      for(let i=0;i<n;i++){
        const ap = aParts[i];
        const bp = bParts[i];
        if(ap == null) return -1;
        if(bp == null) return 1;
        const aNum = /^\d+$/.test(ap);
        const bNum = /^\d+$/.test(bp);
        if(aNum && bNum){
          const ai = Number(ap);
          const bi = Number(bp);
          if(ai !== bi) return ai - bi;
        } else {
          const c = String(ap).localeCompare(String(bp), undefined, { sensitivity: 'base' });
          if(c !== 0) return c;
        }
      }
      return A.localeCompare(B);
    }

    function versionsForPlayer(player){
      if(!eaByPlayer) return [];
      const m = eaByPlayer.get(player);
      if(!m) return [];
      return Array.from(m.keys()).sort(compareGameVersions);
    }
    function setSelectedGameVersion(v){
      selectedGameVersion = v || '';
      const btn = document.getElementById('gameVersionToggle');
      if(btn) btn.textContent = selectedGameVersion || 'Select Game Version';
    }
    function buildGameVersionMenu(versions){
      const menu = document.getElementById('gameVersionMenu');
      if(!menu) return;
      menu.innerHTML='';
      const searchWrap=document.createElement('div'); searchWrap.className='search-box';
      const search=document.createElement('input'); search.type='text'; search.placeholder='Search version...';
      searchWrap.appendChild(search); menu.appendChild(searchWrap);
      const listWrap=document.createElement('div'); listWrap.className='option-list'; menu.appendChild(listWrap);
      function render(q=''){
        listWrap.innerHTML='';
        const term=(q||'').trim().toLowerCase();
        const items = term ? (versions||[]).filter(v=>String(v).toLowerCase().includes(term)) : (versions||[]);
        items.forEach(v=>{
          const label=document.createElement('label');
          const rb=document.createElement('input'); rb.type='radio'; rb.name='gameVersionRadio'; rb.value=v;
          rb.checked = (v===selectedGameVersion);
          rb.addEventListener('change',()=>{
            setSelectedGameVersion(v);
            document.getElementById('gameVersionDropdown').classList.remove('open');
            saveSkatersState();
            refreshActiveTab();
          });
          label.appendChild(rb);
          const span=document.createElement('span'); span.textContent=v; label.appendChild(span);
          listWrap.appendChild(label);
        });
      }
      search.addEventListener('input',()=>render(search.value));
      render('');
    }
    async function syncEaGameVersionsForPlayer(){
      await loadEaRows();
      const versions = versionsForPlayer(selectedPlayer);
      if(versions.length){
        if(!selectedGameVersion || !versions.includes(selectedGameVersion)){
          setSelectedGameVersion(versions[versions.length-1]);
        }
        buildGameVersionMenu(versions);
      } else {
        setSelectedGameVersion('');
        buildGameVersionMenu([]);
      }
    }

    function numVal(row, key){
      if(!row) return null;
      const raw = String(row[key] ?? '').trim();
      if(raw === '') return null;
      const n = Number(raw);
      return Number.isFinite(n) ? n : null;
    }
    function avgInt(row, keys){
      let sum=0, cnt=0;
      for(const k of (keys||[])){
        const v = numVal(row, k);
        if(v==null) continue;
        sum += v; cnt++;
      }
      if(!cnt) return null;
      return Math.round(sum / cnt);
    }
    function setText(id, val){
      const el=document.getElementById(id);
      if(!el) return;
      el.textContent = (val==null || val==='') ? '‚Äî' : String(val);
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function ratingToRgb(val){
      const v = Number(val);
      if(!Number.isFinite(v)) return null;
      const t = clamp01((v - 50) / 49);
      const red = {r:239,g:68,b:68};     // worst
      const blue = {r:59,g:130,b:246};   // best
      return {
        r: Math.round(lerp(red.r, blue.r, t)),
        g: Math.round(lerp(red.g, blue.g, t)),
        b: Math.round(lerp(red.b, blue.b, t)),
        t
      };
    }
    function resetEaCardStyles(){
      const wrap = document.getElementById('eaCards');
      if(!wrap) return;
      wrap.querySelectorAll('[data-ea-card]').forEach(card=>{
        card.style.background = '';
        card.style.borderColor = '';
        const v = card.querySelector('.value');
        if(v) v.style.color = '';
      });
    }
    function applyEaCardColors(){
      const wrap = document.getElementById('eaCards');
      if(!wrap) return;
      wrap.querySelectorAll('[data-ea-card]').forEach(card=>{
        const vEl = card.querySelector('.value');
        const rgb = ratingToRgb(vEl ? vEl.textContent : null);
        if(!rgb) return;
        const {r,g,b} = rgb;
        card.style.background = `rgba(${r},${g},${b},0.14)`;
        card.style.borderColor = `rgba(${r},${g},${b},0.55)`;
        if(vEl) vEl.style.color = `rgb(${r},${g},${b})`;
      });
    }

    function setupCanvasToCss(canvas){
      if(!canvas) return null;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(2, Math.floor(rect.width));
      canvas.height = Math.max(2, Math.floor(rect.height));
      return canvas.getContext('2d');
    }

    function axisClamp5099(v){
      const n = Number(v);
      if(!Number.isFinite(n)) return null;
      return Math.max(50, Math.min(99, n));
    }

    function eaGroupedValuesFromRow(row){
      // Goalie groupings (excluding Overall)
      return {
        'Reflexes': avgInt(row, ['Breakaway','Five Hole','Glove High','Glove Low','Stick High','Stick Low','Rebound Control','Recover']),
        'Puck Control': avgInt(row, ['Passing','Poise','Poke Check','Puck Playing Freq.','Vision']),
        'Athletic': avgInt(row, ['Angles','Aggressiveness','Agility','Speed','Endurance','Durability'])
      };
    }

    function eaLineMetricOptions(){
      // Allow Overall plus the same grouped buckets shown in cards.
      return ['Overall','Reflexes','Puck Control','Athletic'];
    }
    function ensureEaLineMetricMenu(){
      const sel = document.getElementById('eaLineMetric');
      if(!sel) return;
      if(sel.options && sel.options.length) return;
      sel.innerHTML = '';
      eaLineMetricOptions().forEach(m=>{
        const opt=document.createElement('option');
        opt.value = m; opt.textContent = m;
        sel.appendChild(opt);
      });
      const initial = eaLineMetricOptions().includes(selectedEaLineMetric) ? selectedEaLineMetric : 'Overall';
      setSelectedEaLineMetric(initial);
    }
    function setSelectedEaLineMetric(m){
      selectedEaLineMetric = m || 'Overall';
      const sel = document.getElementById('eaLineMetric');
      if(sel) sel.value = selectedEaLineMetric;
    }

    function eaDetailedMetricKeys(row){
      if(!row) return [];
      const excluded = new Set([
        'Game Version','Name','Name_PWHL','PlayerID','Image','Team','Logo',
        'Number','Position','Height','Weight','Age','Gloves','Player Type','Potential','Line Position',
        'Overall'
      ]);
      const keys = Object.keys(row).filter(k=>k && !excluded.has(k) && numVal(row,k)!=null);
      keys.sort((a,b)=>String(a).localeCompare(String(b)));
      return keys;
    }

    const EA_DETAILED_CATEGORY_GROUPS = [
      { name: 'Reflexes', metrics: ['Breakaway','Five Hole','Glove High','Glove Low','Stick High','Stick Low','Rebound Control','Recover'] },
      { name: 'Puck Control', metrics: ['Passing','Poise','Poke Check','Puck Playing Freq.','Vision'] },
      { name: 'Athletic', metrics: ['Angles','Aggressiveness','Agility','Speed','Endurance','Durability'] }
    ];

    function drawSmoothClosedPath(ctx, points){
      const n = (points||[]).length;
      if(n < 2) return;
      if(n === 2){
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        return;
      }
      const t = 1; // tension
      ctx.moveTo(points[0].x, points[0].y);
      for(let i=0;i<n;i++){
        const p0 = points[(i - 1 + n) % n];
        const p1 = points[i];
        const p2 = points[(i + 1) % n];
        const p3 = points[(i + 2) % n];
        const cp1x = p1.x + (p2.x - p0.x) / 6 * t;
        const cp1y = p1.y + (p2.y - p0.y) / 6 * t;
        const cp2x = p2.x - (p3.x - p1.x) / 6 * t;
        const cp2y = p2.y - (p3.y - p1.y) / 6 * t;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }
    }

    function drawTangentialText(ctx, text, cx, cy, r, angle, rotationAdjust = 0){
      const raw = String(text || '').trim();
      if(!raw) return;
      const x = cx + r * Math.cos(angle);
      const y = cy + r * Math.sin(angle);
      let rot = angle + Math.PI/2;
      // Flip labels on the left half so they remain easy to read.
      if(angle > Math.PI/2 && angle < 3*Math.PI/2) rot += Math.PI;
      rot += (rotationAdjust || 0);
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rot);
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(raw, 0, 0);
      ctx.restore();
    }

    function drawEaDetailedRadarCategorized(row){
      const canvas = document.getElementById('eaRadar');
      const ctx = setupCanvasToCss(canvas);
      if(!ctx) return;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      // Background
      const bg = ctx.createLinearGradient(0, 0, 0, h);
      bg.addColorStop(0, '#0f172a');
      bg.addColorStop(1, '#0b1220');
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,w,h);

      const cx = Math.floor(w/2);
      const cy = Math.floor(h/2);
      const padding = 44;
      const radius = Math.max(10, Math.min(cx, cy) - padding);
      const minV = 50;
      const maxV = 99;
      const vToR = (v)=>{
        const vv = axisClamp5099(v);
        if(vv==null) return 0;
        return ((vv - minV) / (maxV - minV)) * radius;
      };

      const cats = EA_DETAILED_CATEGORY_GROUPS.map(c=>({
        name: c.name,
        metrics: (c.metrics||[]).filter(m=>numVal(row, m)!=null)
      })).filter(c=>c.metrics.length);

      if(!cats.length){
        ctx.fillStyle = 'rgba(203,213,225,.75)';
        ctx.font = '12px Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('No detailed EA metrics for player.', 12, 12);
        eaRadarHoverModel = null;
        return;
      }

      const sectorCount = cats.length;
      const sectorSpan = (2*Math.PI) / sectorCount;
      const startBase = -Math.PI/2;

      // Category wedges (3 distinct background colors)
      const wedgeFillFor = (catName)=>{
        const n = String(catName||'');
        if(n === 'Reflexes') return 'rgba(59,130,246,.18)';          // blue
        if(n === 'Puck Control') return 'rgba(142,124,214,.16)';     // lavender accent
        if(n === 'Athletic') return 'rgba(148,163,184,.12)';         // slate
        return 'rgba(148,163,184,.10)';
      };
      for(let i=0;i<sectorCount;i++){
        const a0 = startBase + i * sectorSpan;
        const a1 = a0 + sectorSpan;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.arc(cx, cy, radius + 6, a0, a1);
        ctx.closePath();
        ctx.fillStyle = wedgeFillFor(cats[i] ? cats[i].name : '');
        ctx.fill();

        // Subtle divider
        ctx.strokeStyle = 'rgba(203,213,225,.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + (radius + 6) * Math.cos(a0), cy + (radius + 6) * Math.sin(a0));
        ctx.stroke();
      }

      // Circular grid rings
      const rings = [50, 60, 70, 80, 90, 99];
      ctx.strokeStyle = 'rgba(148,163,184,.26)';
      ctx.lineWidth = 1;
      for(const rv of rings){
        const rr = vToR(rv);
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI*2);
        ctx.stroke();
      }

      // Metric axes + labels
      const axisColor = 'rgba(203,213,225,.20)';
      ctx.strokeStyle = axisColor;
      ctx.lineWidth = 1;
      ctx.shadowColor = 'rgba(15,23,42,.85)';
      ctx.shadowBlur = 6;

      const axisPoints = []; // { x,y,label,value }
      const dataPoints = [];
      for(let ci=0; ci<sectorCount; ci++){
        const cat = cats[ci];
        const a0 = startBase + ci * sectorSpan;
        const m = cat.metrics.length;
        const pad = sectorSpan * 0.14;
        const usable = Math.max(0.0001, sectorSpan - pad*2);
        for(let j=0;j<m;j++){
          const metric = cat.metrics[j];
          const angle = a0 + pad + (j + 0.5) * (usable / m);
          // axis
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.lineTo(cx + radius * Math.cos(angle), cy + radius * Math.sin(angle));
          ctx.stroke();

          // metric label (outer)
          const lx = cx + (radius + 16) * Math.cos(angle);
          const ly = cy + (radius + 16) * Math.sin(angle);
          ctx.font = '10px Segoe UI, Roboto, sans-serif';
          ctx.fillStyle = 'rgba(226,232,240,.88)';
          ctx.textAlign = (Math.cos(angle) > 0.35) ? 'left' : (Math.cos(angle) < -0.35 ? 'right' : 'center');
          ctx.textBaseline = (Math.sin(angle) > 0.35) ? 'top' : (Math.sin(angle) < -0.35 ? 'bottom' : 'middle');
          ctx.fillText(metric, lx, ly);

          const value = numVal(row, metric);
          const rr = vToR(value);
          const px = cx + rr * Math.cos(angle);
          const py = cy + rr * Math.sin(angle);
          axisPoints.push({ x: px, y: py, label: metric, value });
          dataPoints.push({ x: px, y: py });
        }
      }
      ctx.shadowBlur = 0;

      // Category labels (inside the plot, following the circle)
      ctx.fillStyle = 'rgba(248,250,252,.94)';
      ctx.font = '650 12px Segoe UI, Roboto, sans-serif';
      ctx.shadowColor = 'rgba(15,23,42,.85)';
      ctx.shadowBlur = 6;
      const catLabelR = Math.max(10, radius - 8);
      for(let ci=0; ci<sectorCount; ci++){
        const cat = cats[ci];
        const mid = startBase + ci * sectorSpan + sectorSpan/2;
        const rotateCats = (cat.name === 'Puck Control' || cat.name === 'Athletic');
        drawTangentialText(ctx, cat.name, cx, cy, catLabelR, mid, rotateCats ? Math.PI : 0);
      }
      ctx.shadowBlur = 0;

      // Data shape (smooth + filled)
      const lineColor = 'rgba(226,232,240,.95)';
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 2.5;
      ctx.lineJoin = 'round';
      ctx.beginPath();
      drawSmoothClosedPath(ctx, dataPoints);
      ctx.closePath();
      ctx.fillStyle = 'rgba(185,167,255,.20)';
      ctx.fill();
      ctx.stroke();

      // Points
      ctx.fillStyle = lineColor;
      for(const p of dataPoints){
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2);
        ctx.fill();
      }

      eaRadarHoverModel = { points: axisPoints, threshold: 12 };
    }

    // Hover models for EA charts
    let eaRadarHoverModel = null; // { points:[{x,y,label,value}], threshold }
    let eaTrendHoverModel = null; // { points:[{x,y,version,value,metric}], threshold }

    function drawEaRadar(values, labelsOverride){
      const canvas = document.getElementById('eaRadar');
      const ctx = setupCanvasToCss(canvas);
      if(!ctx) return;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);

      // Background (slight depth)
      const bg = ctx.createLinearGradient(0, 0, 0, h);
      bg.addColorStop(0, '#0f172a');
      bg.addColorStop(1, '#0b1220');
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,w,h);

      const labels = (labelsOverride && labelsOverride.length) ? labelsOverride : ['Reflexes','Puck Control','Athletic'];
      const n = labels.length;
      const padding = 34;
      const cx = Math.floor(w/2);
      const cy = Math.floor(h/2);
      const radius = Math.max(10, Math.min(cx, cy) - padding);
      const minV = 50;
      const maxV = 99;
      function vToR(v){
        const vv = axisClamp5099(v);
        if(vv==null) return 0;
        return ((vv - minV) / (maxV - minV)) * radius;
      }

      // Grid rings
      const rings = [50, 60, 70, 80, 90, 99];
      ctx.strokeStyle = 'rgba(148,163,184,.26)';
      ctx.lineWidth = 1;
      for(const rv of rings){
        const rr = vToR(rv);
        ctx.beginPath();
        for(let i=0;i<n;i++){
          const a = (-Math.PI/2) + (i * (2*Math.PI/n));
          const x = cx + rr * Math.cos(a);
          const y = cy + rr * Math.sin(a);
          if(i===0) ctx.moveTo(x,y);
          else ctx.lineTo(x,y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      // Axes + labels
      ctx.font = (n > 14) ? '600 9px Segoe UI, Roboto, sans-serif' : (n > 10 ? '600 10px Segoe UI, Roboto, sans-serif' : '600 12px Segoe UI, Roboto, sans-serif');
      ctx.fillStyle = 'rgba(248,250,252,.98)';
      ctx.strokeStyle = 'rgba(203,213,225,.24)';
      ctx.shadowColor = 'rgba(15,23,42,.85)';
      ctx.shadowBlur = 6;
      for(let i=0;i<n;i++){
        const a = (-Math.PI/2) + (i * (2*Math.PI/n));
        const x2 = cx + radius * Math.cos(a);
        const y2 = cy + radius * Math.sin(a);
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        const labelPad = (n > 10) ? 16 : 14;
        const lx = cx + (radius + labelPad) * Math.cos(a);
        const ly = cy + (radius + labelPad) * Math.sin(a);
        const align = (Math.cos(a) > 0.35) ? 'left' : (Math.cos(a) < -0.35 ? 'right' : 'center');
        const base = (Math.sin(a) > 0.35) ? 'top' : (Math.sin(a) < -0.35 ? 'bottom' : 'middle');
        ctx.textAlign = align;
        ctx.textBaseline = base;
        ctx.fillText(labels[i], lx, ly);
      }
      ctx.shadowBlur = 0;

      // Data polygon (brighter for readability)
      const lineColor = 'rgba(226,232,240,.95)';
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 2.5;
      ctx.lineJoin = 'round';
      ctx.beginPath();

      const hoverPoints = [];
      for(let i=0;i<n;i++){
        const lab = labels[i];
        const rr = vToR(values ? values[lab] : null);
        const a = (-Math.PI/2) + (i * (2*Math.PI/n));
        const x = cx + rr * Math.cos(a);
        const y = cy + rr * Math.sin(a);
        hoverPoints.push({ x, y, label: lab, value: values ? values[lab] : null });
        if(i===0) ctx.moveTo(x,y);
        else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fillStyle = 'rgba(185,167,255,.22)';
      ctx.fill();
      ctx.stroke();

      // Points
      ctx.fillStyle = lineColor;
      for(let i=0;i<n;i++){
        const lab = labels[i];
        const rr = vToR(values ? values[lab] : null);
        const a = (-Math.PI/2) + (i * (2*Math.PI/n));
        const x = cx + rr * Math.cos(a);
        const y = cy + rr * Math.sin(a);
        ctx.beginPath();
        ctx.arc(x, y, 3.4, 0, Math.PI*2);
        ctx.fill();
      }

      // Store hover hit-test model
      eaRadarHoverModel = { points: hoverPoints, threshold: (n > 10 ? 12 : 10) };

      // (No min/max annotation ‚Äî keep clean.)
    }

    const eaLogoCache = new Map();
    function getCachedLogoImage(url){
      const u = String(url||'').trim();
      if(!u) return null;
      const existing = eaLogoCache.get(u);
      if(existing){
        return existing.loaded ? existing.img : null;
      }
      const img = new Image();
      // First try with CORS enabled; if the host doesn't allow it, we'll retry without.
      img.crossOrigin = 'anonymous';
      const entry = { img, loaded:false, error:false, retried:false };
      eaLogoCache.set(u, entry);
      img.onload = ()=>{
        entry.loaded = true;
        if(typeof activeSkaterTab !== 'undefined' && activeSkaterTab === 'ea'){
          // Redraw to swap placeholders for logos.
          drawEaOverallTrend(selectedPlayer, selectedEaLineMetric);
        }
      };
      img.onerror = ()=>{
        if(entry.retried) { entry.error = true; return; }
        // Retry without crossOrigin. Drawing cross-origin images is fine for our use
        // case as long as we don't read pixels back from the canvas.
        entry.retried = true;
        const img2 = new Image();
        entry.img = img2;
        img2.onload = ()=>{
          entry.loaded = true;
          if(typeof activeSkaterTab !== 'undefined' && activeSkaterTab === 'ea'){
            drawEaOverallTrend(selectedPlayer, selectedEaLineMetric);
          }
        };
        img2.onerror = ()=>{ entry.error = true; };
        img2.src = u;
      };
      img.src = u;
      return null;
    }

    function sortGameVersions(versions){
      const toNum = (s)=>{
        const m = String(s||'').match(/(\d+)/);
        return m ? Number(m[1]) : NaN;
      };
      return (versions||[]).slice().sort((a,b)=>{
        const an = toNum(a);
        const bn = toNum(b);
        if(Number.isFinite(an) && Number.isFinite(bn) && an!==bn) return an - bn;
        return String(a).localeCompare(String(b));
      });
    }

    function drawEaOverallTrend(player, metricName){
      const canvas = document.getElementById('eaOverallTrend');
      const ctx = setupCanvasToCss(canvas);
      if(!ctx) return;
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      const bg = ctx.createLinearGradient(0, 0, 0, h);
      bg.addColorStop(0, '#0f172a');
      bg.addColorStop(1, '#0b1220');
      ctx.fillStyle = bg;
      ctx.fillRect(0,0,w,h);

      if(!eaByPlayer || !player || !eaByPlayer.get(player)){
        ctx.fillStyle = 'rgba(203,213,225,.75)';
        ctx.font = '12px Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('No EA data for player.', 12, 12);
        return;
      }

      const verMap = eaByPlayer.get(player);
      const versions = sortGameVersions(Array.from(verMap.keys()));
      const points = versions.map(v=>{
        const row = verMap.get(v);
        let yVal = null;
        const m = String(metricName||'Overall');
        if(m === 'Overall') yVal = numVal(row, 'Overall');
        else {
          const g = eaGroupedValuesFromRow(row);
          yVal = (g && g[m]!=null) ? Number(g[m]) : null;
        }
        return {v, y: yVal, logo: (row ? (row['Logo']||'') : '')};
      }).filter(p=>p.y!=null);

      if(points.length < 1){
        ctx.fillStyle = 'rgba(203,213,225,.75)';
        ctx.font = '12px Segoe UI, Roboto, sans-serif';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'top';
        ctx.fillText('No values found for selected metric.', 12, 12);
        return;
      }

      const padding = {l:46, r:16, t:16, b:104};
      const plotW = Math.max(1, w - padding.l - padding.r);
      const plotH = Math.max(1, h - padding.t - padding.b);
      const minY = 50;
      const maxY = 99;
      function xToPx(i){
        if(points.length===1) return padding.l + plotW * 0.5;
        const t = i / (points.length - 1);
        const xPad = Math.max(10, Math.min(26, plotW * 0.06));
        return padding.l + xPad + t * Math.max(1, (plotW - 2*xPad));
      }
      function yToPx(val){
        const t = (val - minY) / (maxY - minY);
        return padding.t + plotH - t * plotH;
      }

      // Axes
      ctx.strokeStyle = 'rgba(203,213,225,.48)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.l, padding.t);
      ctx.lineTo(padding.l, padding.t + plotH);
      ctx.lineTo(padding.l + plotW, padding.t + plotH);
      ctx.stroke();

      // Y ticks
      ctx.font = '12px Segoe UI, Roboto, sans-serif';
      ctx.fillStyle = 'rgba(203,213,225,.86)';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      const yTicks = [50, 60, 70, 80, 90, 99];
      for(const tv of yTicks){
        const py = yToPx(tv);
        ctx.strokeStyle = 'rgba(148,163,184,.20)';
        ctx.beginPath();
        ctx.moveTo(padding.l, py);
        ctx.lineTo(padding.l + plotW, py);
        ctx.stroke();
        ctx.fillText(String(tv), padding.l - 8, py);
      }

      // Line
      const lineColor = 'rgba(185,167,255,.95)';
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 2.5;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';
      ctx.beginPath();
      for(let i=0;i<points.length;i++){
        const px = xToPx(i);
        const py = yToPx(axisClamp5099(points[i].y) ?? 50);
        if(i===0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.stroke();

      // Points
      ctx.fillStyle = lineColor;
      const trendHoverPoints = [];
      for(let i=0;i<points.length;i++){
        const px = xToPx(i);
        const py = yToPx(axisClamp5099(points[i].y) ?? 50);
        trendHoverPoints.push({ x: px, y: py, version: points[i].v, value: points[i].y, metric: String(metricName||'Overall') });
        const logoImg = getCachedLogoImage(points[i].logo);
        if(logoImg){
          const size = 34;
          ctx.save();
          ctx.beginPath();
          ctx.arc(px, py, size/2, 0, Math.PI*2);
          ctx.clip();
          ctx.drawImage(logoImg, px - size/2, py - size/2, size, size);
          ctx.restore();
          ctx.strokeStyle = 'rgba(15,23,42,.9)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(px, py, size/2, 0, Math.PI*2);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.arc(px, py, 3.2, 0, Math.PI*2);
          ctx.fill();
        }
      }

      eaTrendHoverModel = { points: trendHoverPoints, threshold: 18 };

      // X ticks + labels (every Game Version)
      const xBase = padding.t + plotH;
      ctx.strokeStyle = 'rgba(203,213,225,.28)';
      ctx.lineWidth = 1;
      for(let i=0;i<points.length;i++){
        const px = xToPx(i);
        ctx.beginPath();
        ctx.moveTo(px, xBase);
        ctx.lineTo(px, xBase + 7);
        ctx.stroke();
      }
      ctx.fillStyle = 'rgba(203,213,225,.88)';
      ctx.font = '600 12px Segoe UI, Roboto, sans-serif';
      for(let i=0;i<points.length;i++){
        const px = xToPx(i);
        const label = String(points[i].v||'');
        ctx.save();
        ctx.translate(px, xBase + 16);
        ctx.shadowColor = 'rgba(15,23,42,.85)';
        ctx.shadowBlur = 6;
        ctx.rotate(-Math.PI/6);
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(label, 0, 0);
        ctx.restore();
      }
    }

    function fmtMetricValue(v){
      const n = Number(v);
      if(!Number.isFinite(n)) return '‚Äî';
      return String(Math.round(n));
    }

    function initEaChartHover(){
      const radar = document.getElementById('eaRadar');
      const trend = document.getElementById('eaOverallTrend');

      function getLocalPos(canvas, evt){
        const rect = canvas.getBoundingClientRect();
        const sx = canvas.width / Math.max(1, rect.width);
        const sy = canvas.height / Math.max(1, rect.height);
        const x = (evt.clientX - rect.left) * sx;
        const y = (evt.clientY - rect.top) * sy;
        return { x, y };
      }

      function findNearest(model, x, y){
        if(!model || !model.points || !model.points.length) return null;
        const thr = model.threshold || 12;
        const thr2 = thr*thr;
        let best = null;
        let bestD = Infinity;
        for(const p of model.points){
          const dx = p.x - x;
          const dy = p.y - y;
          const d2 = dx*dx + dy*dy;
          if(d2 <= thr2 && d2 < bestD){ best = p; bestD = d2; }
        }
        return best;
      }

      if(radar){
        radar.addEventListener('mousemove', (evt)=>{
          if(activeSkaterTab !== 'ea') return;
          const {x,y} = getLocalPos(radar, evt);
          const hit = findNearest(eaRadarHoverModel, x, y);
          if(!hit){ hideTooltip(); return; }
          showTooltip(evt, `<div style="font-weight:650;margin-bottom:.15rem">${hit.label}</div><div>Value: ${fmtMetricValue(hit.value)}</div>`);
        });
        radar.addEventListener('mouseleave', ()=>hideTooltip());
      }

      if(trend){
        trend.addEventListener('mousemove', (evt)=>{
          if(activeSkaterTab !== 'ea') return;
          const {x,y} = getLocalPos(trend, evt);
          const hit = findNearest(eaTrendHoverModel, x, y);
          if(!hit){ hideTooltip(); return; }
          showTooltip(evt, `<div style="font-weight:650;margin-bottom:.15rem">${hit.metric}</div><div>${hit.version}: ${fmtMetricValue(hit.value)}</div>`);
        });
        trend.addEventListener('mouseleave', ()=>hideTooltip());
      }
    }

    function clearEaCharts(){
      const r=document.getElementById('eaRadar');
      if(r){ const ctx=setupCanvasToCss(r); if(ctx){ ctx.clearRect(0,0,r.width,r.height); } }
      const t=document.getElementById('eaOverallTrend');
      if(t){ const ctx=setupCanvasToCss(t); if(ctx){ ctx.clearRect(0,0,t.width,t.height); } }
    }

    async function renderEaTab(){
      const msg=document.getElementById('eaMessage');
      if(msg) msg.textContent='';
      ensureEaLineMetricMenu();
      await loadEaRows();
      if(!eaByPlayer){
        if(msg) msg.textContent='EA ratings file could not be loaded.';
        clearEaCharts();
        return;
      }
      const verMap = eaByPlayer.get(selectedPlayer);
      if(!verMap){
        if(msg) msg.textContent='No EA ratings found for this player.';
        ['ea-overall','ea-reflexes','ea-puck-control','ea-athletic'].forEach(id=>setText(id,'‚Äî'));
        resetEaCardStyles();
        document.getElementById('playerName').textContent = selectedPlayer || '‚Äî';
        document.getElementById('playerMeta').textContent = '‚Äî';
        clearEaCharts();
        return;
      }

      const versions = versionsForPlayer(selectedPlayer);
      if(!selectedGameVersion || !versions.includes(selectedGameVersion)) setSelectedGameVersion(versions[versions.length-1] || '');
      buildGameVersionMenu(versions);

      const row = (selectedGameVersion && verMap.get(selectedGameVersion)) ? verMap.get(selectedGameVersion) : (verMap.get(versions[versions.length-1]) || null);
      if(!row){
        if(msg) msg.textContent='No EA ratings found for this player/version.';
        clearEaCharts();
        return;
      }

      document.getElementById('playerName').textContent = String(row['Name_PWHL']||selectedPlayer||'‚Äî');
      const metaParts=[];
      if(row['Number']) metaParts.push('#'+row['Number']);
      if(row['Position']) metaParts.push(row['Position']);
      if(row['Age']) metaParts.push('Age: '+row['Age']);
      if(row['Team']) metaParts.push(row['Team']);
      if(row['Height']) metaParts.push(row['Height']);
      if(row['Weight']) metaParts.push(row['Weight']);
      if(row['Gloves']) metaParts.push('Gloves: '+row['Gloves']);
      if(row['Player Type']) metaParts.push(row['Player Type']);
      if(row['Potential']) metaParts.push(row['Potential']);
      document.getElementById('playerMeta').textContent = metaParts.length ? metaParts.join(' ‚Ä¢ ') : '‚Äî';

      const imgUrl = String(row['Image']||'').trim();
      if(imgUrl){
        const img=document.getElementById('playerAvatar');
        if(img) img.src = imgUrl;
      } else {
        updateAvatar();
      }

      // Cards (remember these groupings)
      const overall = numVal(row, 'Overall');
      setText('ea-overall', overall==null ? '‚Äî' : Math.round(overall));
      setText('ea-reflexes', avgInt(row, ['Breakaway','Five Hole','Glove High','Glove Low','Stick High','Stick Low','Rebound Control','Recover']) ?? '‚Äî');
      setText('ea-puck-control', avgInt(row, ['Passing','Poise','Poke Check','Puck Playing Freq.','Vision']) ?? '‚Äî');
      setText('ea-athletic', avgInt(row, ['Angles','Aggressiveness','Agility','Speed','Endurance','Durability']) ?? '‚Äî');

      resetEaCardStyles();
      applyEaCardColors();

      // Charts
      const radarModeSel = document.getElementById('eaRadarMode');
      const radarMode = radarModeSel ? radarModeSel.value : 'grouped';
      if(radarMode === 'detailed'){
        drawEaDetailedRadarCategorized(row);
      } else {
        drawEaRadar(eaGroupedValuesFromRow(row));
      }
      // Trend ignores the Game Version slicer (uses all versions for the selected player)
      drawEaOverallTrend(selectedPlayer, selectedEaLineMetric);
    }

    // Team color cache
    const teamColorCache = (function(){ let colors=null; return async function(team){ if(colors) return colors[team]||'#53b3ff'; try{ const resp=await fetch('/Teams.csv'); if(resp.ok){ colors={}; const txt=await resp.text(); const lines=txt.split(/\n/); lines.shift(); lines.forEach(l=>{ const c=l.split(','); if(c.length>5){ colors[c[1]]=c[5]; }}); return colors[team]||'#53b3ff'; } }catch(e){} return '#53b3ff'; }; })();

    // Rink
    function setupCanvas(c){ c.width=c.clientWidth; c.height=c.clientHeight; return c.getContext('2d'); }
    const RINK_SRC='/hockey-rink.png'; let rinkImgPromise=null; function loadRink(){ if(rinkImgPromise) return rinkImgPromise; rinkImgPromise=new Promise(res=>{const i=new Image(); i.onload=()=>res(i); i.src=RINK_SRC;}); return rinkImgPromise; }
    async function drawZoneBases(){
      const img=await loadRink();
      const sw=img.naturalWidth, sh=img.naturalHeight;
      const zoneW=sw*0.375;
      ['heatRinkBase','offRinkBase'].forEach(id=>{
        const c=document.getElementById(id);
        if(!c) return;
        const ctx=setupCanvas(c);
        ctx.clearRect(0,0,c.width,c.height);
        ctx.drawImage(img,sw-zoneW,0,zoneW,sh,0,0,c.width,c.height);
      });
    }
    // Offensive zone coordinate system (feet): x in [25, 100] => 75 wide, y in [-42.5, 42.5] => 85 high
    const OFF_X_MIN = 25;
    const OFF_X_MAX = 100;
    const OFF_Y_MIN = -42.5;
    const OFF_Y_MAX = 42.5;
    function normalizeOffZoneCoord(x,y){ return { zx:(x-OFF_X_MIN)/75, zy:(OFF_Y_MAX - y)/85 }; }

    /** ---------------- Heat Map (Zone Geometry) ---------------- */
    // Offensive-zone polygons (O01..O26) copied from the Report page embedded geometry.
    const SKATER_OFF_ZONES = {"type":"FeatureCollection","features":[
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,-12.5],[100,-12.5],[100,-14],[99.9989034876783,-14.25],[99.99561369755,-14.5],[99.9901298698339,-14.75],[99.9824507372522,-15],[99.9725745235657,-15.25],[99.9604989415154,-15.5],[99.9462211901686,-15.75],[99.929737951659,-16],[99.9110453873137,-16.25],[99.8901391331568,-16.5],[99.8670142947755,-16.75],[99.8416654415368,-17],[99.814086600136,-17.25],[99.7842712474619,-17.5],[99.752212302756,-17.75],[99.7179021190449,-18],[99.6813324738203,-18.25],[99.6424945589406,-18.5],[99.6013789697232,-18.75],[99.5579756931964,-19],[99.5122740954747,-19.25],[99.4642629082191,-19.5],[99.4139302141422,-19.75],[99.3612634315101,-20],[99.306249297595,-20.25],[99.2488738510232,-20.5],[99.1891224129621,-20.75],[99.1269795670826,-21],[99.0624291382309,-21.25],[98.995454169735,-21.5],[98.9260368992678,-21.75],[98.8541587331799,-22],[98.7798002192098,-22.25],[98.7029410174709,-22.5],[98.6235598696041,-22.75],[98.5416345659799,-23],[98.4571419108184,-23.25],[98.3700576850888,-23.5],[98.2803566070357,-23.75],[98.188012290165,-24],[98.0929971985107,-24.25],[97.9952825989835,-24.5],[97.8948385105876,-24.75],[97.7916336502698,-25],[97.6856353751441,-25.25],[97.5768096208106,-25.5],[97.4651208354592,-25.75],[97.3505319094211,-26],[97.2330040997937,-26.25],[97.1124969497314,-26.5],[96.9889682019496,-26.75],[96.8623737059448,-27],[96.7326673183792,-27.25],[96.5998007960223,-27.5],[96.463723680573,-27.75],[96.3243831746128,-28],[96.1817240078565,-28.25],[96.0356882927706,-28.5],[95.8862153685233,-28.75],[95.7332416321053,-29],[95.5767003553228,-29.25],[95.4165214862028,-29.5],[95.2526314331697,-29.75],[95.0849528301415,-30],[94.9134042804544,-30.25],[94.7379000772445,-30.5],[94.5583498975967,-30.75],[94.3746584673957,-31],[94.1867251933813,-31.25],[93.994443758404,-31.5],[93.7977016752848,-31.75],[93.5963797939844,-32],[93.3903517559677,-32.25],[93.1794833886788,-32.5],[92.9636320318813,-32.75],[92.742645786248,-33],[92.516362672927,-33.25],[92.2846096908265,-33.5],[92.0472017559569,-33.75],[91.803940504247,-34],[91.5546129356814,-34.25],[91.2989898732233,-34.5],[91.036824204563,-34.75],[90.7678488679977,-35],[90.4917745353087,-35.25],[90.2082869338697,-35.5],[89.917043736713,-35.75],[89.6176709319934,-36],[89.3097585609688,-36.25],[89,-36.5],[89,-12.5]]]},"properties":{"id":"O01","ZONE":"O"},"id":"O01"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,-12.5],[100,-12.5],[100,12.5],[89,12.5],[89,-12.5]]]},"properties":{"id":"O02","ZONE":"O"},"id":"O02"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,12.5],[100,12.5],[100,14],[99.9989034876783,14.25],[99.99561369755,14.5],[99.9901298698339,14.75],[99.9824507372522,15],[99.9725745235657,15.25],[99.9604989415154,15.5],[99.9462211901686,15.75],[99.929737951659,16],[99.9110453873137,16.25],[99.8901391331568,16.5],[99.8670142947755,16.75],[99.8416654415368,17],[99.814086600136,17.25],[99.7842712474619,17.5],[99.752212302756,17.75],[99.7179021190449,18],[99.6813324738203,18.25],[99.6424945589406,18.5],[99.6013789697232,18.75],[99.5579756931964,19],[99.5122740954747,19.25],[99.4642629082191,19.5],[99.4139302141422,19.75],[99.3612634315101,20],[99.306249297595,20.25],[99.2488738510232,20.5],[99.1891224129621,20.75],[99.1269795670826,21],[99.0624291382309,21.25],[98.995454169735,21.5],[98.9260368992678,21.75],[98.8541587331799,22],[98.7798002192098,22.25],[98.7029410174709,22.5],[98.6235598696041,22.75],[98.5416345659799,23],[98.4571419108184,23.25],[98.3700576850888,23.5],[98.2803566070357,23.75],[98.188012290165,24],[98.0929971985107,24.25],[97.9952825989835,24.5],[97.8948385105876,24.75],[97.7916336502698,25],[97.6856353751441,25.25],[97.5768096208106,25.5],[97.4651208354592,25.75],[97.3505319094211,26],[97.2330040997937,26.25],[97.1124969497314,26.5],[96.9889682019496,26.75],[96.8623737059448,27],[96.7326673183792,27.25],[96.5998007960223,27.5],[96.463723680573,27.75],[96.3243831746128,28],[96.1817240078565,28.25],[96.0356882927706,28.5],[95.8862153685233,28.75],[95.7332416321053,29],[95.5767003553228,29.25],[95.4165214862028,29.5],[95.2526314331697,29.75],[95.0849528301415,30],[94.9134042804544,30.25],[94.7379000772445,30.5],[94.5583498975967,30.75],[94.3746584673957,31],[94.1867251933813,31.25],[93.994443758404,31.5],[93.7977016752848,31.75],[93.5963797939844,32],[93.3903517559677,32.25],[93.1794833886788,32.5],[92.9636320318813,32.75],[92.742645786248,33],[92.516362672927,33.25],[92.2846096908265,33.5],[92.0472017559569,33.75],[91.803940504247,34],[91.5546129356814,34.25],[91.2989898732233,34.5],[91.036824204563,34.75],[90.7678488679977,35],[90.4917745353087,35.25],[90.2082869338697,35.5],[89.917043736713,35.75],[89.6176709319934,36],[89.3097585609688,36.25],[89,36.5],[89,12.5]]]},"properties":{"id":"O03","ZONE":"O"},"id":"O03"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,-36.5],[89,-28],[60,-42.5],[71.5,-42.5],[75.2666297933298,-42.25],[76.8150729063673,-42],[77.9951905283833,-41.75],[78.9833147735479,-41.5],[79.847903928532,-41.25],[80.6241437954473,-41],[81.3329802196486,-40.75],[81.9880884817015,-40.5],[82.5989864402116,-40.25],[83.1726175299288,-40],[83.7142335003061,-39.75],[84.2279220613579,-39.5],[84.7169398878863,-39.25],[85.183932183404,-39],[85.6310827610626,-38.75],[86.060219778561,-38.5],[86.472892172189,-38.25],[86.8704261489394,-38],[87.2539677541882,-37.75],[87.6245154965971,-37.5],[87.9829457318769,-37.25],[88.3300326797068,-37],[88.6664644001029,-36.75],[89,-36.5]]]},"properties":{"id":"O04","ZONE":"O"},"id":"O04"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,-28],[89,-16],[73,-24],[73,-36],[89,-28]]]},"properties":{"id":"O05","ZONE":"O"},"id":"O05"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,-16],[89,-4],[73,-12],[73,-24],[89,-16]]]},"properties":{"id":"O06","ZONE":"O"},"id":"O06"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,-4],[89,4],[83,7],[83,-7],[89,-4]]]},"properties":{"id":"O07","ZONE":"O"},"id":"O07"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,4],[89,16],[73,24],[73,12],[89,4]]]},"properties":{"id":"O08","ZONE":"O"},"id":"O08"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,16],[89,28],[73,36],[73,24],[89,16]]]},"properties":{"id":"O09","ZONE":"O"},"id":"O09"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[89,36.5],[89,28],[60,42.5],[71.5,42.5],[75.2666297933298,42.25],[76.8150729063673,42],[77.9951905283833,41.75],[78.9833147735479,41.5],[79.847903928532,41.25],[80.6241437954473,41],[81.3329802196486,40.75],[81.9880884817015,40.5],[82.5989864402116,40.25],[83.1726175299288,40],[83.7142335003061,39.75],[84.2279220613579,39.5],[84.7169398878863,39.25],[85.183932183404,39],[85.6310827610626,38.75],[86.060219778561,38.5],[86.472892172189,38.25],[86.8704261489394,38],[87.2539677541882,37.75],[87.6245154965971,37.5],[87.9829457318769,37.25],[88.3300326797068,37],[88.6664644001029,36.75],[89,36.5]]]},"properties":{"id":"O10","ZONE":"O"},"id":"O10"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[83,-7],[83,7],[73,12],[73,-12],[83,-7]]]},"properties":{"id":"O11","ZONE":"O"},"id":"O11"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,-36],[73,-24],[57,-32],[57,-42.5],[60,-42.5],[73,-36]]]},"properties":{"id":"O12","ZONE":"O"},"id":"O12"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,-24],[73,-12],[57,-20],[57,-32],[73,-24]]]},"properties":{"id":"O13","ZONE":"O"},"id":"O13"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,-12],[73,0],[57,-8],[57,-20],[73,-12]]]},"properties":{"id":"O14","ZONE":"O"},"id":"O14"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,0],[57,8],[57,-8],[73,0]]]},"properties":{"id":"O15","ZONE":"O"},"id":"O15"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,0],[73,12],[57,20],[57,8],[73,0]]]},"properties":{"id":"O16","ZONE":"O"},"id":"O16"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,12],[73,24],[57,32],[57,20],[73,12]]]},"properties":{"id":"O17","ZONE":"O"},"id":"O17"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[73,24],[73,36],[60,42.5],[57,42.5],[57,32],[73,24]]]},"properties":{"id":"O18","ZONE":"O"},"id":"O18"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[57,-42.5],[57,-20],[41,-28],[41,-42.5],[57,-42.5]]]},"properties":{"id":"O19","ZONE":"O"},"id":"O19"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[57,-20],[57,-8],[41,-16],[41,-28],[57,-20]]]},"properties":{"id":"O20","ZONE":"O"},"id":"O20"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[57,-8],[57,8],[41,16],[41,-16],[57,-8]]]},"properties":{"id":"O21","ZONE":"O"},"id":"O21"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[57,8],[57,20],[41,28],[41,16],[57,8]]]},"properties":{"id":"O22","ZONE":"O"},"id":"O22"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[57,20],[57,42.5],[41,42.5],[41,28],[57,20]]]},"properties":{"id":"O23","ZONE":"O"},"id":"O23"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[41,-42.5],[41,-16],[25,-24],[25,-42.5],[41,-42.5]]]},"properties":{"id":"O24","ZONE":"O"},"id":"O24"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[41,-16],[41,16],[25,24],[25,-24],[41,-16]]]},"properties":{"id":"O25","ZONE":"O"},"id":"O25"},
      {"type":"Feature","geometry":{"type":"Polygon","coordinates":[[[41,16],[41,42.5],[25,42.5],[25,24],[41,16]]]},"properties":{"id":"O26","ZONE":"O"},"id":"O26"}
    ]};

    function projectOffensivePoint(x,y){
      const zx = (x - OFF_X_MIN) / 75;
      const zy = (OFF_Y_MAX - y) / 85;
      return [zx, zy];
    }
    function drawZonePathOff(ctx, feature){
      const coords=feature.geometry.coordinates[0];
      ctx.beginPath();
      let started=false;
      for(const pt of coords){
        const x=pt[0], y=pt[1];
        if(x < OFF_X_MIN) continue;
        const [px,py]=projectOffensivePoint(x,y);
        const cx=px*ctx.canvas.width;
        const cy=py*ctx.canvas.height;
        if(!started){ ctx.moveTo(cx,cy); started=true; }
        else ctx.lineTo(cx,cy);
      }
      ctx.closePath();
    }
    function pointInPoly(poly,x,y){
      let inside=false;
      for(let i=0,j=poly.length-1;i<poly.length;j=i++){
        const xi=poly[i][0], yi=poly[i][1];
        const xj=poly[j][0], yj=poly[j][1];
        const intersect=((yi>y)!==(yj>y)) && (x < (xj - xi)*(y - yi)/(yj - yi + 1e-9) + xi);
        if(intersect) inside=!inside;
      }
      return inside;
    }
    function heatColor(val,minVal,maxVal){
      if(maxVal<=minVal) return 'rgba(255,220,220,0.35)';
      const t=(val-minVal)/(maxVal-minVal);
      const r=255;
      const g=Math.round(220*(1-t)+25*t);
      const b=Math.round(220*(1-t)+40*t);
      const a=0.25 + 0.55*t;
      return `rgba(${r},${g},${b},${a})`;
    }
    function attemptZoneIdOff(a){
      if(!a || a.adj_x==null || a.adj_y==null) return null;
      const x=Number(a.adj_x), y=Number(a.adj_y);
      if(!Number.isFinite(x) || !Number.isFinite(y)) return null;
      if(x < OFF_X_MIN || x > OFF_X_MAX || y < OFF_Y_MIN || y > OFF_Y_MAX) return null;
      for(const feat of (SKATER_OFF_ZONES.features||[])){
        const poly=feat.geometry.coordinates[0];
        if(pointInPoly(poly,x,y)) return feat.properties.id;
      }
      return null;
    }
    async function drawHeatMap(attempts){
      const c=document.getElementById('heatCanvas');
      if(!c) return;
      const ctx=setupCanvas(c);
      ctx.clearRect(0,0,c.width,c.height);

      // Heat map always shows overall distribution (not goalie-filtered);
      // clicking a zone will apply the zone filter to the table + shot map.
      const counts={};
      for(const a of (attempts||[])){
        if(!a || a.adj_x==null || a.adj_y==null) continue;
        if(a.event!=='Shot' && a.event!=='Goal' && a.event!=='Miss' && a.event!=='Block') continue;
        const zid=attemptZoneIdOff(a);
        if(!zid) continue;
        counts[zid]=(counts[zid]||0)+1;
      }

      const vals = (SKATER_OFF_ZONES.features||[]).map(f=>counts[f.properties.id]||0);
      const minVal = vals.length ? Math.min(...vals) : 0;
      const maxVal = vals.length ? Math.max(...vals) : 1;

      for(const feat of (SKATER_OFF_ZONES.features||[])){
        const id=feat.properties.id;
        drawZonePathOff(ctx, feat);
        const v=counts[id]||0;
        ctx.fillStyle=heatColor(v,minVal,maxVal);
        ctx.fill();
        const isSelected = (selectedZoneId && selectedZoneId === id);
        ctx.lineWidth = isSelected ? 2 : 1;
        ctx.strokeStyle = isSelected ? 'rgba(0,0,0,0.75)' : 'rgba(255,255,255,0.25)';
        ctx.stroke();
      }
    }

    // Heat-map click handling (single-zone selection)
    let selectedZoneId = '';
    function setSelectedZone(id){ selectedZoneId = id || ''; }
    function attachHeatZoneEvents(){
      const canvas=document.getElementById('heatCanvas');
      if(!canvas || canvas._zoneEventsAttached) return;
      canvas._zoneEventsAttached=true;
      canvas.addEventListener('click', (e)=>{
        const rect=canvas.getBoundingClientRect();
        const x=(e.clientX-rect.left)/rect.width;
        const y=(e.clientY-rect.top)/rect.height;
        const ctx=canvas.getContext('2d');
        let hitId='';
        for(const feat of (SKATER_OFF_ZONES.features||[])){
          ctx.beginPath();
          drawZonePathOff(ctx, feat);
          if(ctx.isPointInPath(x*canvas.width, y*canvas.height)) hitId = feat.properties.id;
          ctx.closePath();
          if(hitId) break;
        }

        if(hitId && selectedZoneId === hitId) hitId = ''; // toggle off
        setSelectedZone(hitId);
        saveSkatersState();

        // Recompute table (zone-filtered) + redraw heat highlight + redraw shot map
        updateGoalieTableFromAttempts();
        drawHeatMap(allAttempts);
        drawShotMap(allAttempts);
      });
    }

    function attemptsFilteredByZone(attempts){
      if(!selectedZoneId) return (attempts||[]);
      return (attempts||[]).filter(a=>attemptZoneIdOff(a) === selectedZoneId);
    }

    function computeShooterRowsFromAttempts(attempts){
      const byShooter={};
      for(const a of (attempts||[])){
        if(!a || !a.shooter) continue;
        const ev=a.event;
        // Match backend: Shots are SOG only (Shot + Goal)
        if(ev!=='Shot' && ev!=='Goal') continue;
        const sname=String(a.shooter||'').trim();
        if(!sname) continue;
        const rec = byShooter[sname] || (byShooter[sname]={Shooter:sname, Goals:0, Shots:0, xG:0});
        rec.Shots += 1;
        if(ev==='Goal') rec.Goals += 1;
        const xv = (a.xG!==undefined && a.xG!==null && a.xG!=='') ? Number(a.xG) : 0;
        if(Number.isFinite(xv)) rec.xG += xv;
      }

      const out=[];
      Object.values(byShooter).forEach(rec=>{
        const shots=rec.Shots||0;
        const goals=rec.Goals||0;
        const xg=Math.round((rec.xG||0)*100)/100;
        const shPct=Math.round(((shots? (goals/shots*100):0)*10))/10;
        const gsax=Math.round(((xg - goals)*100))/100;
        out.push({
          Shooter: rec.Shooter,
          Goals: goals,
          Shots: shots,
          xG: xg,
          'Sh%': shPct,
          GSAx: gsax,
        });
      });

      // Default sort by GSAx desc
      out.sort((a,b)=> (b.GSAx - a.GSAx) || (b.xG - a.xG) || (b.Shots - a.Shots) || String(a.Shooter).localeCompare(String(b.Shooter)));
      return out;
    }

    function updateGoalieTableFromAttempts(){
      // Table should be filtered by selected zone, but not by selected shooter.
      const zoneAttempts = attemptsFilteredByZone(allAttempts);
      shooterRows = computeShooterRowsFromAttempts(zoneAttempts);

      // If selected shooter no longer exists after zone filter, clear it.
      if(selectedShooter && !shooterRows.some(r=>r.Shooter===selectedShooter)){
        setSelectedShooter('');
      }

      renderGoalieTable(shooterRows);
    }

    function drawShape(ctx, shape, x, y, color){ ctx.save(); ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=1.4; switch(shape){ case 'goal': ctx.beginPath(); ctx.moveTo(x,y-5); ctx.lineTo(x+4.5,y+5); ctx.lineTo(x-4.5,y+1.5); ctx.lineTo(x+4.5,y+1.5); ctx.lineTo(x-4.5,y+5); ctx.closePath(); ctx.fill(); break; case 'shot': ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.stroke(); break; case 'miss': ctx.beginPath(); ctx.moveTo(x,y-5); ctx.lineTo(x+5,y+5); ctx.lineTo(x-5,y+5); ctx.closePath(); ctx.stroke(); break; case 'block': ctx.strokeRect(x-5,y-5,10,10); break; } ctx.restore(); }

    // Tooltip (reuse styles from report)
    const tooltip=document.createElement('div'); tooltip.style.cssText='position:absolute;pointer-events:none;background:rgba(20,24,38,.94);border:1px solid #6b7280;padding:.55rem .7rem;border-radius:.5rem;font-size:.7rem;line-height:1.25;z-index:200;display:none;max-width:210px;white-space:normal;font-weight:500;'; document.body.appendChild(tooltip);
    function toHexColor(color){ try{ const c=document.createElement('canvas'); const ctx=c.getContext('2d'); ctx.fillStyle=color; const s=ctx.fillStyle; if(/^#[0-9a-fA-F]{6}$/.test(s)) return s; }catch(e){} return null; }
    function ensureReadableOnDark(color, targetBrightness=185, maxFactor=0.45){ try{ const hex = toHexColor(color) || (typeof color==='string' && color.startsWith('#') && color.length===7 ? color : null); if(!hex) return color; const h=hex.slice(1); let r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16); const luminance = (0.2126*r + 0.7152*g + 0.0722*b); const denom = (0.2126*(255-r) + 0.7152*(255-g) + 0.0722*(255-b)); let f = denom>0 ? (targetBrightness - luminance) / denom : 0; f = Math.max(0, Math.min(f, maxFactor)); const lr=Math.round(r+(255-r)*f), lg=Math.round(g+(255-g)*f), lb=Math.round(b+(255-b)*f); const toHex=v=>('0'+v.toString(16)).slice(-2); return '#'+toHex(lr)+toHex(lg)+toHex(lb); }catch(e){ return color; } }
    function showTooltip(evt, html){ tooltip.innerHTML=html; tooltip.style.display='block'; const pad=12; const x=(evt.clientX + window.scrollX) + pad; const y=(evt.clientY + window.scrollY) + pad; tooltip.style.left=x+'px'; tooltip.style.top=y+'px'; }
    function hideTooltip(){ tooltip.style.display='none'; }

    let allAttempts=[];
    let selectedShooter='';
    function setSelectedShooter(name){ selectedShooter = name || ''; }

    // Sub-tabs (EA Ratings / Shooting / Performance)
    let activeSkaterTab = 'shooting';
    function updateFilterVisibilityForTab(){
      const eaOnly = document.getElementById('eaOnlyFilters');
      const nonEa = document.getElementById('nonEaFilters');
      const statCards = document.getElementById('goalieStatCards');
      const eaCards = document.getElementById('eaCards');
      const isEa = (activeSkaterTab === 'ea');
      if(eaOnly) eaOnly.classList.toggle('hidden', !isEa);
      if(nonEa) nonEa.classList.toggle('hidden', isEa);
      if(statCards) statCards.classList.toggle('hidden', isEa);
      if(eaCards) eaCards.classList.toggle('hidden', !isEa);
    }
    function setSkaterTab(tab){
      activeSkaterTab = tab || 'shooting';
      document.querySelectorAll('#skaterTabs .subtab').forEach(btn=>{
        const t = btn.getAttribute('data-tab');
        const isActive = (t === activeSkaterTab);
        btn.classList.toggle('active', isActive);
        btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
      });
      document.querySelectorAll('.subtab-panel').forEach(p=>p.classList.remove('active'));
      const panel = document.getElementById('tab-' + activeSkaterTab);
      if(panel) panel.classList.add('active');
      updateFilterVisibilityForTab();
      // Ensure view is updated immediately when switching tabs.
      saveSkatersState();
      refreshActiveTab();
    }
    function initSkaterTabs(){
      const wrap = document.getElementById('skaterTabs');
      if(!wrap) return;
      wrap.querySelectorAll('.subtab').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const tab = btn.getAttribute('data-tab') || 'shooting';
          setSkaterTab(tab);
        });
      });
    }

    // Shooter table sorting
    let shooterRows=[];
    let goalieSortKey='GSAx';
    let goalieSortDir='desc';
    function isNumericKey(key){ return key!=='Shooter'; }
    function normalizeSortVal(row, key){
      const v = row ? row[key] : null;
      if(key==='Shooter') return String(v||'').toLowerCase();
      const n = Number(v);
      return Number.isFinite(n) ? n : (v==null ? -Infinity : Number(v));
    }
    function sortGoalieRows(rows){
      const dir = goalieSortDir === 'desc' ? -1 : 1;
      const key = goalieSortKey;
      return (rows||[]).slice().sort((a,b)=>{
        const av = normalizeSortVal(a,key);
        const bv = normalizeSortVal(b,key);
        if(av < bv) return -1*dir;
        if(av > bv) return 1*dir;
        // stable-ish tie-break
        const an = String(a.Shooter||'');
        const bn = String(b.Shooter||'');
        return an.localeCompare(bn);
      });
    }
    function renderGoalieSortIndicators(){
      document.querySelectorAll('thead th.sortable').forEach(th=>{
        const base = th.getAttribute('data-base') || th.textContent.replace(/[\s‚ñ≤‚ñº]+$/,'').trim();
        th.setAttribute('data-base', base);
        const key = th.getAttribute('data-sort');
        if(key === goalieSortKey){
          th.textContent = base + (goalieSortDir==='desc' ? ' ‚ñº' : ' ‚ñ≤');
        } else {
          th.textContent = base;
        }
      });
    }
    function initGoalieTableSorting(){
      document.querySelectorAll('thead th.sortable').forEach(th=>{
        th.addEventListener('click', ()=>{
          const key = th.getAttribute('data-sort');
          if(!key) return;
          if(goalieSortKey === key){
            goalieSortDir = (goalieSortDir === 'desc') ? 'asc' : 'desc';
          } else {
            goalieSortKey = key;
            goalieSortDir = (key === 'Shooter') ? 'asc' : 'desc';
          }
          renderGoalieSortIndicators();
          renderGoalieTable(shooterRows);
        });
      });
      renderGoalieSortIndicators();
    }

    async function drawShotMap(attempts){
      const offC=document.getElementById('offShotCanvas');
      const offCtx=setupCanvas(offC);
      offCtx.clearRect(0,0,offC.width,offC.height);

      const zoneAttempts = attemptsFilteredByZone(attempts||[]);
      const filteredAttempts = selectedShooter ? zoneAttempts.filter(a=>a.shooter===selectedShooter) : zoneAttempts;

      const teamsSet=new Set(); filteredAttempts.forEach(a=>{ if(a && a.forTeam) teamsSet.add(a.forTeam); });
      const colorByTeam={}; for(const nm of teamsSet){ colorByTeam[nm]=await teamColorCache(nm); }

      const pointIndex=[];
      for(const a of filteredAttempts){
        if(a.adj_x==null||a.adj_y==null) continue;
        const x=a.adj_x, y=a.adj_y;
        // Only offensive zone (75x85 feet)
        if(x < OFF_X_MIN || x > OFF_X_MAX) continue;
        if(y < OFF_Y_MIN || y > OFF_Y_MAX) continue;
        const {zx,zy}=normalizeOffZoneCoord(x,y);
        const shape = a.event==='Goal'?'goal': a.event==='Shot'?'shot': a.event==='Miss'?'miss': a.event==='Block'?'block':'shot';
        const px=zx*offCtx.canvas.width; const py=zy*offCtx.canvas.height;
        const col=colorByTeam[a.forTeam]||'#53b3ff';
        drawShape(offCtx, shape, px, py, col);
        pointIndex.push({canvas:offCtx.canvas,x:px,y:py,r:7,data:a,colorByTeam});
      }

      function handleMove(e){
        let found=null;
        for(const p of pointIndex){
          const rect=p.canvas.getBoundingClientRect();
          const mx=e.clientX, my=e.clientY;
          if(mx<rect.left||mx>rect.right||my<rect.top||my>rect.bottom) continue;
          const dx=mx- (rect.left + p.x/ p.canvas.width * rect.width);
          const dy=my- (rect.top + p.y/ p.canvas.height * rect.height);
          const dist=Math.hypot(dx,dy);
          if(dist <= p.r){ found=p; break; }
        }
        if(found){
          const d=found.data;
          const tipColor=ensureReadableOnDark(colorByTeam[d.forTeam]||'#53b3ff');
          const html=`<strong style='color:${tipColor}'>${d.forTeam}</strong><br>${d.event} (${d.strength||''})<br>Shooter: ${d.shooter||'‚Äî'}<br>Goalie: ${d.goalie||'‚Äî'}<br>Period: ${d.period}`;
          showTooltip(e, html);
        } else hideTooltip();
      }

      offC.onmousemove = handleMove;
      offC.onmouseleave = hideTooltip;
    }

    // Data
    async function populateFilters(){
      const r=await fetch('/api/goalies/filters');
      if(!r.ok) return;
      const data=await r.json();
      allPlayers = (data.players||[]);
      if((!selectedPlayer || !allPlayers.includes(selectedPlayer)) && allPlayers.length){
        setSelectedPlayer(allPlayers[0]);
      }
      buildPlayerMenu(allPlayers);
      buildMenu('seasons', data.seasons||[]);
      buildMenu('season_states', data.season_states||[]);
      buildMenu('strengths', data.strengths||[]);
      // Restore multi-select filter state (if present)
      if(pendingRestoreState && pendingRestoreState.multi){
        applyMultiSelections('seasons', pendingRestoreState.multi.seasons);
        applyMultiSelections('season_states', pendingRestoreState.multi.season_states);
        applyMultiSelections('strengths', pendingRestoreState.multi.strengths);
      } else {
        multiIds.forEach(updateButtonLabel);
      }
      await syncEaGameVersionsForPlayer();
    }
    function params(){ const p=new URLSearchParams(); p.set('player', selectedPlayer); multiIds.forEach(id=>{ getMultiValues(id).forEach(v=>p.append(id, v)); }); return p; }
    async function fetchStats(){
      const r=await fetch('/api/goalies/stats?'+params().toString());
      if(!r.ok) return;
      const data=await r.json();
      document.getElementById('playerName').textContent=data.player||'‚Äî';
      const p=data.profile||{};
      const parts=[];
      if(p.jersey) parts.push('#'+p.jersey);
      if(p.position) parts.push(p.position);
      if(p.age!=null && p.age!=='' && !Number.isNaN(Number(p.age))) parts.push('Age: '+p.age);
      if(p.team) parts.push(p.team);
      document.getElementById('playerMeta').textContent = parts.length ? parts.join(' ‚Ä¢ ') : '‚Äî';
      const s=data.stats||{};
      document.getElementById('stat-gp').textContent=s.GP??'‚Äî';
      document.getElementById('stat-toi').textContent=s.TOI??'‚Äî';
      document.getElementById('stat-sa').textContent=s.SA??'‚Äî';
      document.getElementById('stat-ga').textContent=s.GA??'‚Äî';
      document.getElementById('stat-sv').textContent=s['Sv%']??'‚Äî';
      document.getElementById('stat-xga').textContent=s.xGA??'‚Äî';
      document.getElementById('stat-xsv').textContent=s['xSv%']??'‚Äî';
      document.getElementById('stat-dsv').textContent=s['dSv%']??'‚Äî';
      document.getElementById('stat-gsax').textContent=s.GSAx??'‚Äî';
    }
    async function fetchShotMap(){
      const r=await fetch('/api/goalies/shotmap?'+params().toString());
      if(!r.ok) return;
      const data=await r.json();
      allAttempts = (data.attempts||[]);
      updateGoalieTableFromAttempts();
      await drawHeatMap(allAttempts);
      await drawShotMap(allAttempts);
    }

    // Performance
    let performanceData = null;
    function metricIsFloat(metric){ return metric==='xGA' || metric==='GSAx' || metric==='TOI'; }
    function yFmt(metric, v, mode){
      const num = Number(v);
      if(!Number.isFinite(num)) return '0';
      if(metricIsFloat(metric)) return (Math.round(num*100)/100).toFixed(2);
      // Moving average can be fractional even for integer metrics
      if(mode==='ma') return (Math.round(num*100)/100).toFixed(2);
      return String(Math.round(num));
    }
    function setupChartCanvas(canvas){
      if(!canvas) return null;
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.max(2, Math.floor(rect.width));
      canvas.height = Math.max(2, Math.floor(rect.height));
      return canvas.getContext('2d');
    }
    function drawPerformanceChart(){
      const canvas = document.getElementById('perfChart');
      const ctx = setupChartCanvas(canvas);
      if(!ctx) return;
      ctx.clearRect(0,0,canvas.width,canvas.height);

      const metricSel = document.getElementById('perfMetric');
      const metric = metricSel ? metricSel.value : 'GSAx';
      const modeSel = document.getElementById('perfMode');
      const mode = modeSel ? modeSel.value : 'running';
      const maIn = document.getElementById('perfMaWindow');
      const maWindow = Math.max(1, Math.floor(Number(maIn ? maIn.value : 5) || 5));
      const games = (performanceData && performanceData.games) ? performanceData.games : [];
      const xs = games.map(g=>Number(g.gameNumber||0)).filter(n=>Number.isFinite(n) && n>0);
      const perGame = games.map(g=>{
        const pv = (g.per_game && g.per_game[metric] != null) ? g.per_game[metric] : 0;
        const n = Number(pv);
        return Number.isFinite(n) ? n : 0;
      });
      const running = games.map(g=>{
        const rv = (g.running && g.running[metric] != null) ? g.running[metric] : 0;
        const n = Number(rv);
        return Number.isFinite(n) ? n : 0;
      });
      const ys = (mode === 'ma') ? (function(){
        const out=[];
        for(let i=0;i<perGame.length;i++){
          const start=Math.max(0, i - maWindow + 1);
          let sum=0;
          for(let j=start;j<=i;j++) sum += perGame[j];
          out.push(sum / (i - start + 1));
        }
        return out;
      })() : running;

      // If no data, render an empty frame.
      const padding = {l:56, r:18, t:28, b:38};
      const w = canvas.width, h = canvas.height;
      const plotW = Math.max(1, w - padding.l - padding.r);
      const plotH = Math.max(1, h - padding.t - padding.b);

      // Background
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0,0,w,h);

      // (Intentionally no chart title/header; controls already show metric + mode.)

      // Axes
      ctx.strokeStyle = 'rgba(203,213,225,.45)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding.l, padding.t);
      ctx.lineTo(padding.l, padding.t + plotH);
      ctx.lineTo(padding.l + plotW, padding.t + plotH);
      ctx.stroke();

      if(!xs.length){
        ctx.fillStyle = 'rgba(203,213,225,.75)';
        ctx.font = '12px Segoe UI, Roboto, sans-serif';
        ctx.fillText('No games found for current filters.', padding.l, padding.t + 18);
        return;
      }

      const xMin = 1;
      const xMax = Math.max(...xs);
      const yMin = Math.min(0, Math.min(...ys));
      const yMax = Math.max(yMin + 1e-6, Math.max(...ys));

      function xToPx(x){
        const t = (xMax === xMin) ? 0 : ((x - xMin) / (xMax - xMin));
        return padding.l + t * plotW;
      }
      function yToPx(y){
        const t = (yMax === yMin) ? 0 : ((y - yMin) / (yMax - yMin));
        return padding.t + plotH - t * plotH;
      }

      // Season shading + boundaries + labels
      const seasons = games.map(g=>String(g.season||''));
      const segments=[];
      let curStart=1;
      for(let i=0;i<seasons.length;i++){
        const s = seasons[i];
        const prev = (i===0) ? s : seasons[i-1];
        if(i>0 && s !== prev){
          segments.push({season: prev, start: curStart, end: i});
          curStart = i+1;
        }
      }
      segments.push({season: seasons[seasons.length-1] || '', start: curStart, end: seasons.length});

      for(let si=0; si<segments.length; si++){
        const seg=segments[si];
        const x0 = xToPx(seg.start);
        const x1 = xToPx(seg.end);
        ctx.fillStyle = (si % 2 === 0) ? 'rgba(185,167,255,.05)' : 'rgba(255,255,255,.03)';
        ctx.fillRect(x0, padding.t, (x1 - x0), plotH);
        if(si>0){
          const boundaryX = xToPx(seg.start - 0.5);
          ctx.strokeStyle = 'rgba(203,213,225,.32)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(boundaryX, padding.t);
          ctx.lineTo(boundaryX, padding.t + plotH);
          ctx.stroke();
        }

        // Season label (above plot area)
        const label = seg.season || '';
        if(label){
          const midX = (x0 + x1) / 2;
          ctx.save();
          ctx.font = '600 13px Segoe UI, Roboto, sans-serif';
          ctx.fillStyle = 'rgba(203,213,225,.82)';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'top';
          const labelY = Math.max(2, padding.t - 16);
          ctx.fillText(label, midX, labelY);
          ctx.restore();
        }
      }

      // Grid + y ticks
      const yTicks = 5;
      ctx.font = '11px Segoe UI, Roboto, sans-serif';
      for(let i=0;i<=yTicks;i++){
        const tv = yMin + (yMax - yMin) * (i / yTicks);
        const py = yToPx(tv);
        ctx.strokeStyle = 'rgba(148,163,184,.18)';
        ctx.beginPath();
        ctx.moveTo(padding.l, py);
        ctx.lineTo(padding.l + plotW, py);
        ctx.stroke();
        ctx.fillStyle = 'rgba(203,213,225,.75)';
        ctx.textAlign = 'right';
        ctx.textBaseline = 'middle';
        ctx.fillText(yFmt(metric, tv, mode), padding.l - 8, py);
      }

      // X label ticks (start, mid, end)
      const xTicks = [1, Math.ceil(xMax/2), xMax].filter((v,i,a)=>a.indexOf(v)===i);
      ctx.fillStyle = 'rgba(203,213,225,.75)';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      for(const xv of xTicks){
        const px = xToPx(xv);
        ctx.fillText(String(xv), px, padding.t + plotH + 8);
      }
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      ctx.fillText('Game #', padding.l + plotW - 48, padding.t + plotH + 8);

      // Baseline (y=0) if range includes negatives
      if(yMin < 0 && yMax > 0){
        const y0 = yToPx(0);
        ctx.strokeStyle = 'rgba(229,231,235,.22)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(padding.l, y0);
        ctx.lineTo(padding.l + plotW, y0);
        ctx.stroke();
      }

      // Line + subtle area fill
      const lineColor = 'rgba(185,167,255,.95)';
      const fillGrad = ctx.createLinearGradient(0, padding.t, 0, padding.t + plotH);
      fillGrad.addColorStop(0, 'rgba(185,167,255,.18)');
      fillGrad.addColorStop(1, 'rgba(185,167,255,0)');

      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      // Area
      ctx.beginPath();
      for(let i=0;i<ys.length;i++){
        const x = i+1;
        const y = ys[i];
        const px = xToPx(x);
        const py = yToPx(y);
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      const lastX = xToPx(ys.length);
      const baseY = yToPx(Math.max(yMin, 0));
      ctx.lineTo(lastX, baseY);
      ctx.lineTo(xToPx(1), baseY);
      ctx.closePath();
      ctx.fillStyle = fillGrad;
      ctx.fill();

      // Stroke
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 2.25;
      ctx.beginPath();
      for(let i=0;i<ys.length;i++){
        const x = i+1;
        const y = ys[i];
        const px = xToPx(x);
        const py = yToPx(y);
        if(i===0) ctx.moveTo(px,py);
        else ctx.lineTo(px,py);
      }
      ctx.stroke();

      // Emphasize last point
      const lastY = ys[ys.length-1];
      const lpX = xToPx(ys.length);
      const lpY = yToPx(lastY);
      ctx.fillStyle = lineColor;
      ctx.beginPath();
      ctx.arc(lpX, lpY, 3.5, 0, Math.PI*2);
      ctx.fill();
      // (No end-value label; keeps chart cleaner.)
    }

    async function fetchPerformance(){
      const r = await fetch('/api/goalies/performance?' + params().toString());
      if(!r.ok) return;
      performanceData = await r.json();
      drawPerformanceChart();
    }

    function refreshActiveTab(){
      updateAvatar();
      // Always update player identity card immediately.
      if(activeSkaterTab === 'ea'){
        renderEaTab();
        return;
      }
      fetchStats();
      if(activeSkaterTab === 'performance'){
        fetchPerformance();
      } else if(activeSkaterTab === 'shooting'){
        fetchShotMap();
      }
    }

    function renderGoalieTable(rows){
      const body=document.getElementById('goalieTableBody');
      body.innerHTML='';
      const sorted = sortGoalieRows(rows||[]);
      (sorted||[]).forEach(row=>{
        const tr=document.createElement('tr');
        if(selectedShooter && selectedShooter===row.Shooter) tr.classList.add('active');
        tr.innerHTML = `
          <td title="${row.Shooter}">${row.Shooter}</td>
          <td>${row.Goals}</td>
          <td>${row.Shots}</td>
          <td>${row.xG}</td>
          <td>${row['Sh%']}</td>
          <td>${row.GSAx}</td>
        `;
        tr.addEventListener('click',()=>{
          if(selectedShooter === row.Shooter){
            setSelectedShooter('');
          } else {
            setSelectedShooter(row.Shooter);
          }
          saveSkatersState();
          // Re-render selection + redraw shots
          renderGoalieTable(shooterRows);
          drawShotMap(allAttempts);
        });
        body.appendChild(tr);
      });
    }

    // Image: prefer API-provided player image URL, fallback to local static or placeholder
    function localAvatarSrc(name){ const file = (name||'').toLowerCase().replace(/[^a-z0-9]+/g,'_') + '.jpg'; return '/static/players/'+file; }
    async function updateAvatar(){ const name=selectedPlayer; const img=document.getElementById('playerAvatar');
      try{
        const resp=await fetch('/api/goalies/player_image?'+new URLSearchParams({player:name}).toString());
        if(resp.ok){ const data=await resp.json(); const url=(data&&data.url)||''; if(url){ img.src=url; return; }
        }
      }catch(e){}
      // Fallback to local static file
      try{ const src=localAvatarSrc(name); const head=await fetch(src,{method:'HEAD'}); img.src = head.ok ? src : '/static/Thumbnail.png'; }catch(e){ img.src='/static/Thumbnail.png'; }
    }

    multiIds.forEach(id=>{
      document.querySelector(`#${id}Menu`).addEventListener('change',()=>{
        updateButtonLabel(id);
        setSelectedShooter('');
        setSelectedZone('');
        saveSkatersState();
        refreshActiveTab();
      });
    });

    function syncPerfControls(){
      const modeSel=document.getElementById('perfMode');
      const ma=document.getElementById('perfMaWindow');
      if(!modeSel || !ma) return;
      ma.disabled = (modeSel.value !== 'ma');
    }
    document.addEventListener('change', (e)=>{
      if(!e || !e.target) return;
      if(e.target.id === 'perfMetric' || e.target.id === 'perfMode'){
        syncPerfControls();
        saveSkatersState();
        drawPerformanceChart();
      }
    });
    document.addEventListener('input', (e)=>{
      if(e && e.target && e.target.id === 'perfMaWindow'){
        saveSkatersState();
        drawPerformanceChart();
      }
    });

    document.addEventListener('change', (e)=>{
      if(!e || !e.target) return;
      if(e.target.id === 'eaRadarMode'){
        saveSkatersState();
        if(activeSkaterTab === 'ea') renderEaTab();
      }
      if(e.target.id === 'eaLineMetric'){
        setSelectedEaLineMetric(e.target.value);
        saveSkatersState();
        if(activeSkaterTab === 'ea'){
          drawEaOverallTrend(selectedPlayer, selectedEaLineMetric);
        }
      }
    });

    (async()=>{
      // Load persisted state before initial fetches
      pendingRestoreState = loadSkatersState();
      if(pendingRestoreState){
        if(pendingRestoreState.selectedPlayer) setSelectedPlayer(pendingRestoreState.selectedPlayer);
        if(pendingRestoreState.selectedGameVersion) setSelectedGameVersion(pendingRestoreState.selectedGameVersion);
        if(pendingRestoreState.selectedEaLineMetric) setSelectedEaLineMetric(pendingRestoreState.selectedEaLineMetric);
        if(pendingRestoreState.shooting){
          if(pendingRestoreState.shooting.selectedShooter) setSelectedShooter(pendingRestoreState.shooting.selectedShooter);
          if(pendingRestoreState.shooting.selectedZoneId) setSelectedZone(pendingRestoreState.shooting.selectedZoneId);
        }
      }
      await populateFilters();
      await drawZoneBases();
      initGoalieTableSorting();
      attachHeatZoneEvents();
      initSkaterTabs();
      initEaChartHover();
      // Restore control selections (EA + Performance) after DOM is ready
      if(pendingRestoreState){
        const radarModeSel = document.getElementById('eaRadarMode');
        if(radarModeSel && pendingRestoreState.eaRadarMode) radarModeSel.value = pendingRestoreState.eaRadarMode;
        const lineMetricSel = document.getElementById('eaLineMetric');
        if(lineMetricSel && (pendingRestoreState.ea && pendingRestoreState.ea.lineMetric)){
          setSelectedEaLineMetric(pendingRestoreState.ea.lineMetric);
          lineMetricSel.value = pendingRestoreState.ea.lineMetric;
        }
        const perfMetricSel = document.getElementById('perfMetric');
        const perfModeSel = document.getElementById('perfMode');
        const perfMaIn = document.getElementById('perfMaWindow');
        if(perfMetricSel && pendingRestoreState.performance && pendingRestoreState.performance.metric) perfMetricSel.value = pendingRestoreState.performance.metric;
        if(perfModeSel && pendingRestoreState.performance && pendingRestoreState.performance.mode) perfModeSel.value = pendingRestoreState.performance.mode;
        if(perfMaIn && pendingRestoreState.performance && pendingRestoreState.performance.maWindow!=null) perfMaIn.value = String(pendingRestoreState.performance.maWindow);
      }

      // Restore tab and trigger initial render
      const tabToUse = (pendingRestoreState && pendingRestoreState.activeSkaterTab) ? pendingRestoreState.activeSkaterTab : 'shooting';
      pendingRestoreState = null;
      setSkaterTab(tabToUse);
      syncPerfControls();
      window.addEventListener('resize',()=>{
        if(activeSkaterTab === 'shooting'){
          drawZoneBases();
          fetchShotMap();
        } else if(activeSkaterTab === 'ea'){
          renderEaTab();
        } else if(activeSkaterTab === 'performance'){
          drawPerformanceChart();
        }
      });
    })();
  </script>
</body>
</html>
